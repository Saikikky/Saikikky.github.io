<!DOCTYPE html>



  


<html class="theme-next mist use-motion" lang>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">



  
  
    
    
  <script src="/lib/pace/pace.min.js?v=1.0.2"></script>
  <link href="/lib/pace/pace-theme-minimal.min.css?v=1.0.2" rel="stylesheet">







<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta property="og:type" content="website">
<meta property="og:title" content="Saikikky">
<meta property="og:url" content="http://yoursite.com/page/2/index.html">
<meta property="og:site_name" content="Saikikky">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Saikikky">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/page/2/">





  <title>Saikikky</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="default">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>
    
    <a href="https://github.com/Saikikky" class="github-corner" aria-label="View source on GitHub"><svg width="80" height="80" viewbox="0 0 250 250" style="fill:#151513; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"/><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"/><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"/></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Saikikky</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            Archives
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/08/06/自定义注解/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Saikikky Wang">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Saikikky">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/08/06/自定义注解/" itemprop="url">自定义注解</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-08-06T08:59:05+08:00">
                2019-08-06
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="自定义注解"><a href="#自定义注解" class="headerlink" title="自定义注解"></a>自定义注解</h3><p>注解本身不做任何事，就像一个标记或者一个配置，用于包、类型、构造方法、方法、成员变量、参数及本地变量的标记</p>
<p>程序后续可以利用Java的反射机制来了解各种元素是否有何标记，作出相应的操作。(后续的反射函数要自己来实现)</p>
<h4 id="元注解"><a href="#元注解" class="headerlink" title="元注解"></a>元注解</h4><ul>
<li>元注解就是注解的注解，用来描述注解。</li>
</ul>
<p>注解的基本语法是：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(&#123;ElementType.METHOD, ElementType.TYPE&#125;)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> AnnotationName &#123;</span><br><span class="line">  String [] value() <span class="keyword">default</span> <span class="string">""</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong><em>规定注解中只能使用Java八大基本数据类型和String、enum、Annotation、class</em></strong></p>
<ul>
<li>@Retention 定义该注解的生命周期<ul>
<li>RetentionPolicy.SOURCE：作用于源码阶段，比如常见的@Override 和@SuppressWarnings</li>
<li>RetentionPolicy.CLASS: 作用于字节码阶段</li>
<li>RetentionPolicy.RUNTIME：作用于运行阶段</li>
</ul>
</li>
<li>@Target 定义该注解的作用范围<ul>
<li>ElementType.TYPE：用于注解到类，接口、枚举类型</li>
<li>ElementType.FIELD：字段，包括枚举类常量</li>
<li>ElementType.METHOD：方法声明</li>
<li>ElementType.PARAMETER：参数声明</li>
<li>ElementType.CONSTRUCTOR：构造器声明</li>
<li>ElementType.LOCAL_VARIABLE ：局部变量声明</li>
<li>ElementType.ANNOTATION_TYPE ：用于注解声明，即注解的注解，元注解</li>
<li>ElementType.PACKAGE ：包声明</li>
</ul>
</li>
<li>其他注解<ul>
<li>@Document 注解将生成到javadoc中</li>
<li>@Deprecated 表示过时的类</li>
<li>@Inherited 是否允许子类即成该注解</li>
<li>@SuppressWarnings 编译器忽略掉无法识别的警告名</li>
<li>@Override 标注的方法重载了父类的方法</li>
</ul>
</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/08/05/熔断、限流和降级/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Saikikky Wang">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Saikikky">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/08/05/熔断、限流和降级/" itemprop="url">熔断、限流和降级</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-08-05T08:59:05+08:00">
                2019-08-05
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="熔断、限流和降级-rabbit-mq"><a href="#熔断、限流和降级-rabbit-mq" class="headerlink" title="熔断、限流和降级(rabbit mq)"></a>熔断、限流和降级(rabbit mq)</h2><h3 id="熔断"><a href="#熔断" class="headerlink" title="熔断"></a>熔断</h3><p>熔断机制是应对雪崩效应的一种微服务链路保护机制，一般情况下当内部出现错误导致某个微服务不可用或者响应时间太长的情况，会进行服务的降级，进而熔断该节点微服务的调用，快读返回错误的响应信息。当检测到该节点微服务调用响应正常之后，恢复调用链路。</p>
<p>在Spring Cloud中，Hystrix会监控微服务间调用的状况，当失败的调用到一定阈值，缺省是5秒内20次调用失败，就会启动熔断机制。</p>
<p>熔断解决一下问题：</p>
<ul>
<li>当所依赖的对象不稳定时，能够起到快速失败的目的</li>
<li>快速失败之后，能够根据一定的算法动态试探所依赖的对象是否恢复</li>
</ul>
<h3 id="限流"><a href="#限流" class="headerlink" title="限流"></a>限流</h3><p>限流的目的是通过对并发反问/请求进行限速或者一个时间窗口内的请求进行限速来保护系统，一旦达到限制速率则可以拒绝服务(定向到错误页或告知资源没有了)、排队或者等待(比如秒杀、评论、下单)、降级(返回兜底数据或默认数据，如商品详情页库存默认有货)。</p>
<p>一般情况下，开发高并发系统常见的限流有：限制总并发数(数据库连接池、线程池)、限制瞬时并发数、限制时间窗口内的平均速率，其他还有限制远程接口调用速率、限制MQ的消费速率，另外还可以根据网络连接数、网络流量、CPU或内存负载等来限流。</p>
<h3 id="降级"><a href="#降级" class="headerlink" title="降级"></a>降级</h3><p>降级是指自己的待遇下降了，从RPC调用环节来讲，就是去访问一个本地的伪装者而不是真正的服务。当服务器压力剧增的情况下，根据实际业务情况及流量，对一些服务和页面有策略的不处理或换种简单的方式处理，从而释放服务器资源以及保证核心交易正常运作或高效运作。</p>
<p>服务降级主要用于：当整个微服务架构整体的负载超出了预设的上限阈值或即将到来的流量预计将会超过预设的阈值时，为了保证重要的或基本的服务能正常运行，可以将一些不重要或者不紧急的服务或任务进行服务的延迟使用或暂停使用。</p>
<p>当某个模块内部出现问题，直接将入口取消掉，接口关闭，不会影响其他模块的运行。</p>
<p>当微服务A调用微服务B时，不直接调用B，而是给一个RabbitMQ发送message，此时A为生产者，消息就存储在MQ中，之后B有一个监听listen，可以监听到有内容发送了，当B没有问题的时候会从MQ中读取message，<u>当A发现一段时间之后B没有读取内容会重新发送？？？(不确定)</u></p>
<h3 id="RabbitMQ"><a href="#RabbitMQ" class="headerlink" title="RabbitMQ"></a>RabbitMQ</h3><p>消息队列主要用途：不同进程Process/线程Thread之间通信。</p>
<p>MQ是一种常见的上下游“逻辑解耦+物理解耦”的消息通信服务。</p>
<ul>
<li>不同进程之间传递消息时，两个进程之间耦合程度过高，改动一个进程，引发必须修改另一个进程，为了隔离这两个进程，在两进程间抽离出一层(一个模块)，所有两进程之间传递的消息，都必须通过消息队列来传递，单独修改某一个进程，不会影响另一个。</li>
<li>不同进程之间传递消息时，为了实现标准化，将消息的格式规范化了，并且，某一个进程接受的消息太多，一下子无法处理完，并且也有先后顺序，必须对收到的消息进行排队，因此诞生了事实上的消息队列。</li>
</ul>
<p><strong>什么时候使用MQ</strong></p>
<ul>
<li><p>数据驱动的任务依赖(任务之间有依赖关系)</p>
<p>MQ用来传递上游任务执行完成的消息，并不用于传递真正的输入输出数据。</p>
</li>
<li><p>上游不关心执行结果</p>
</li>
<li><p>上游关注执行结果，但执行时间很长(调用离线处理，或者跨公网调用)</p>
</li>
</ul>
<p>MQ的不足是：</p>
<ul>
<li>系统更加复杂，多了一个MQ组件。</li>
<li>消息传递路径更长，延时会增加。</li>
<li>消息可靠性和重复性互为矛盾，消息不丢不重难以同时保证。</li>
<li>生产者无法知道消费者的执行结果。</li>
</ul>
<p><strong>调用方实时依赖执行结果的业务场景，要用直接调用，而不是MQ</strong>。</p>
<p>例如：用户登录场景，登录页面调用passport服务，passport服务的执行结果直接影响登录结果，此处的“登录页面”与“passport服务”就必须使用调用关系，而不能使用MQ通信。<strong><em>调用与被调用的关系，是无法被MQ取代的。</em></strong> </p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/07/29/搭建Spring Cloud Demo中遇到的问题/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Saikikky Wang">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Saikikky">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/07/29/搭建Spring Cloud Demo中遇到的问题/" itemprop="url">搭建Spring Cloud Demo中遇到的问题</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-07-29T08:59:05+08:00">
                2019-07-29
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <ol>
<li><p>SpringCloud无法引入@EnableFeignClients问题**</p>
<p>问题描述：</p>
<p>SpringBoot版本为2.1.6.RELEASE，Spring Cloud版本为Greenwich.SR2，在启动类上加@EnableFeignClients时，提示找不到响应的包，已经导入feign的依赖。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--引入feign--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-feign<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>版本不兼容问题，修改SpringBoot版本为1.5.13.RELEASE，Spring Cloude版本为Edgware.SR4后导入成功。(公司pom文件显示用的是1.5.11.RELEASE版本的SpringBoot和Edgware.RELEASE版本的Spring Cloud)</p>
</li>
<li><p><strong>服务消费者无法调用服务提供者的方法</strong></p>
<p>问题描述：</p>
<p>Eureka注册中心启动正常，服务提供者和服务调用者都成功注册到注册中心，其中注册中心端口号为8000，提供者端口号为9000，调用者端口号为9001。全部成功启动之后，直接调用服务提供者提供的方法可以成功访问，但通过调用者9001端口访问服务显示feign.RetryableException: Read timed out executing GET <a href="http://spring-cloud-producer/hello?name=s]" target="_blank" rel="noopener">http://spring-cloud-producer/hello?name=s]</a> with root cause错误，百度发现是超时问题修改了各种熔断 ribbon和feign配置都不起作用。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 同一实例最大重试次数，不包括首次调用。默认值为0</span></span><br><span class="line"><span class="string">ribbon.MaxAutoRetries=0</span></span><br><span class="line"><span class="comment"># 同一个微服务其他实例的最大重试次数，不包括第一次调用的实例。默认值为1</span></span><br><span class="line"><span class="string">ribbon.MaxAutoRetriesNextServer=0</span></span><br><span class="line"><span class="comment"># 是否所有操作（GET、POST等）都允许重试。默认值为false</span></span><br><span class="line"><span class="string">ribbon.OkToRetryOnAllOperations=false</span></span><br><span class="line"><span class="comment">## 设置连接超时时间</span></span><br><span class="line"><span class="string">ribbon.ConnectTimeout=60000</span></span><br><span class="line"><span class="comment">## 设置读取超时时间</span></span><br><span class="line"><span class="string">ribbon.ReadTimeout=60000</span></span><br><span class="line"><span class="comment">## 关闭feign的熔断</span></span><br><span class="line"><span class="string">feign.hystrix.enabled=false</span></span><br><span class="line"><span class="comment">## 用于禁用Hystrix的超时时间</span></span><br><span class="line"><span class="string">hystrix.command.default.execution.timeout.enabled=false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## 对所有操作请求都进行重试</span></span><br><span class="line"><span class="string">ribbon.OkToRetryOnAllOperations=true</span></span><br><span class="line"><span class="comment">## 切换实例的重试次数</span></span><br><span class="line"><span class="string">ribbon.MaxAutoRetriesNextServer=2</span></span><br><span class="line"><span class="comment">## 对当前实例的重试次数</span></span><br><span class="line"><span class="string">ribbon.MaxAutoRetries=1</span></span><br></pre></td></tr></table></figure>
<p>最后问题是8000端口无法访问？？但注册中心正常启动且服务提供端也可以正常启动  改成8080端口之后可以访问，重启电脑之后8000端口也可以访问，初步判断是端口占用的问题，但Eureka注册和服务器调用注册等的端口是如何工作的要再了解一下。</p>
<p>项目正常运行之后 通过netstat -anp tcp命令查看端口使用情况发现启用了五个127.0.0.1.8000 所以Eureka注册中心启动的时候究竟启动了几个怎么启动的需要看下。</p>
</li>
<li><p>设置FeignClient中的fallback不起作用，发现是没有打开feign对hystrix的支持。在配置文件中加入如下配置。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">feign:</span></span><br><span class="line"><span class="attr">  hystrix:</span></span><br><span class="line"><span class="attr">    enabled:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>
</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/07/22/Spring Cloud/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Saikikky Wang">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Saikikky">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/07/22/Spring Cloud/" itemprop="url">Spring Cloud</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-07-22T08:59:05+08:00">
                2019-07-22
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="Spring-Cloud"><a href="#Spring-Cloud" class="headerlink" title="Spring Cloud"></a>Spring Cloud</h2><h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>Spring Cloud不是云计算解决方案，而是在SpringBoot上构建的，用于快速构建分布式系统的通用模式的工具集。</p>
<p><strong><em>Spring Cloud是一个基于Spring Boot实现的云原生应用开发工具，它为基于JVM的云原生应用开发中涉及的配置管理、服务发现、熔断器、智能路由、微代理、控制总线、分布式会话和集群状态管理等操作提供了一种简单的开发方式。</em></strong></p>
<h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><ul>
<li>约定大于配置</li>
<li>适用于各种环境</li>
<li>隐藏了组件的复杂性，并提供声明式、无XML的配置方式</li>
<li>开箱即用，快速启动</li>
<li>组件丰富，功能齐全</li>
</ul>
<h4 id="核心子项目"><a href="#核心子项目" class="headerlink" title="核心子项目"></a>核心子项目</h4><p>微服务是可以独立部署、水平扩展、独立访问（或者有独立的数据库）的服务单元，SpringCloud就是这些微服务的大管家，采用了微服务这种架构之后，项目的数量会非常多，SpringCloud做为大管家需要管理好这些微服务，自然需要很多小弟来帮忙。</p>
<p>Netflix 与各种Netflix OSS组件集成，组成微服务的核心。</p>
<p>Config 配置管理工具，实现应用配置的外部化存储，支持客户端配置信息刷新、加密/解密配置内容等。</p>
<p>Bus 事件、消息总线，用于传播集群中的状态变化或事件，以及触发后续的处理。</p>
<p>Security等</p>
<h3 id="Eureka-服务中心"><a href="#Eureka-服务中心" class="headerlink" title="Eureka(服务中心)"></a>Eureka(服务中心)</h3><p>是一款提供服务注册和发现的产品。服务中心又叫注册中心，管理各种服务功能包括服务的注册、发现、熔断、负载、降级等，有了服务中心之后，所有调用都要通过服务中心去调用。</p>
<p>Eureka是一个基于REST的服务，主要在AWS云中使用，定位服务来进行中间层服务器的负载均衡和故障转移。</p>
<p>Eureka由两个组件组成：Eureka服务器和Eureka客户端。服务器用作服务注册服务器，客户端是一个Java客户端，用来简化与服务器的交互、作为轮询负载均衡器，并提供服务的故障切换支持。</p>
<p>Eureka Server提供服务注册和发现，Service Provider服务提供方，将自身服务注册到Eureka，从而使服务消费方能够找到，Service Consumer服务消费方，从Eureka获取注册服务列表，从而能够消费服务。</p>
<p>Eureka是Netflix服务发现的服务端与客户端，Eureka提供服务注册以及服务发现的能力，当是Eureka Server时(注册中心)，所有的客户端会向其注册，当是Eureka Client时，可以从注册中心获取对应的服务信息，或者是向Eureka Server将自己作为实例注册进去，每个Eureka不仅仅是一个服务端同时还是一个客户端。</p>
<p>当Eureka想要成为注册中心时，必须将注册中心的服务地址指向自己，同时禁用服务检索的功能。Eureka是一个高可用的组件，它没有后端缓存，每一个实例注册之后需要向注册中心发送心跳来检测服务的可用性，注册中心不处理请求的转发，只是记录每个实例注册进来的信息。</p>
<p>注册中心页面：<a href="http://localhost:8000/" target="_blank" rel="noopener">http://localhost:8000/</a></p>
<p>+++</p>
<p><strong>集群</strong></p>
<p>为了维持注册中心的高可用性，通常会使用集群，Eureka通过互相注册的方式来实现高可用的部署，所以只需要将Eureka Server配置其他可用的serviceUrl就可以实现高可用部署。</p>
<p>+++</p>
<p><strong>服务的提供与调用</strong></p>
<p>三个角色：服务注册中心、服务提供者和服务消费者。流程是首先启动注册中心，服务提供者生产服务并注册到服务中心中，消费者从服务中心中获取服务并执行。</p>
<ul>
<li>服务提供者的启动类上加上@EnableDiscoveryClient注解：能够让注册中心能够发现，扫描到该服务。</li>
</ul>
<p>@EnableDiscoveryClient和@EnableEurekaClient的区别是：后者只能用于Eureka做注册中心时，但前者也可以用于其他注册中心。</p>
<ul>
<li>服务消费者的启动类上加上@EnableFeignClients注解：启用feign进行远程调用。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Feign是一个声明式Web Service客户端。使用Feign能让编写Web Service客户端更加简单，它的使用方法是定义一个接口，然后在上面添加注解，同时也支持JAX-RS标准的注解。Feign也支持可拔插式的编码器和解码器。Spring Cloud对Feign进行了封装，使其支持Spring MVC标准注解和HttpMessageConverters。Feign可以与Eureka和Ribbon组合使用支持负载均衡。</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="Ribbon"><a href="#Ribbon" class="headerlink" title="Ribbon"></a>Ribbon</h4><p>服务消费者有两个目标分别是发现服务和消费服务，其中服务发现的任务由Eureka的客户端完成，服务消费的任务则由Ribbon完成。Ribbon是一个基于HTTP和TCP的客户端负载均衡器，可以在通过客户端中配置的ribbonServerList服务端列表去轮询访问以达到均衡负载的作用。当Ribbon和Eureka联合使用时，Ribbon的服务实例清单RibbonServerList会被DiscoveryEnabledNIWSServerList重写，扩展成从Eureka注册中心中获取服务端列表。</p>
<ul>
<li>服务提供者只需要启动多个服务实例并注册到一个注册中心或是多个相关联的服务注册中心。</li>
<li>服务消费者直接通过调用被@LoadBalanced注解修饰过的RestTemplate来实现面向服务的接口调用。</li>
</ul>
<p>Ribbon开启负载均衡，在启动类中加入如下方法和注解@LoadBalanced</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@LoadBalanced</span></span><br><span class="line"><span class="function">RestTemplate <span class="title">restTemplate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> RestTemplate();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//RestTemplate是Spring提供的用于访问Rest服务的客户端，RestTemplate提供了多种便捷访问远程Http服务的方法,能够大大提高客户端的编写效率。</span></span><br></pre></td></tr></table></figure>
<p>Spring Cloud Ribbon 通过LoadBalancerInterceptor拦截器对RestTemplate的请求进行拦截，并利用Spring Cloud的负载均衡器LoadBalancerClient将以逻辑服务名为host的URI转换成具体的服务实例地址的过程。</p>
<h5 id="客户端负载均衡"><a href="#客户端负载均衡" class="headerlink" title="客户端负载均衡"></a>客户端负载均衡</h5><p>负载均衡是对系统的高可用、网络压力的缓解和处理能力扩容的重要手段之一。一般的负载均衡指的是服务端的负载均衡，负责负载均衡的模块会维护一个下挂可用的服务端清单，通过心跳检测来保证清单中的都是可以用的服务器节点。而客户端的负载均衡和服务端的最大区别是服务清单所存储的位置，这些服务清单来源于注册中心，也需要心跳去维持服务端清单的健康性，只是需要和服务注册中心配合完成。</p>
<p>+++</p>
<h4 id="Feign"><a href="#Feign" class="headerlink" title="Feign"></a>Feign</h4><p>Spring Cloud Feign整合了Spring Cloud Ribbon和Spring Cloud Hystrix。帮助定义和实现依赖服务接口的定义，在Feign的实现下，只需创建一个接口并用注解的方式来配置它，即可完成对服务提供方的接口绑定。</p>
<ul>
<li><strong>Feign</strong>调用实现</li>
</ul>
<p>Feign支持服务的调用以及均衡负载。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FeignClient</span>(name= <span class="string">"spring-cloud-producer"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">HelloRemote</span> </span>&#123;</span><br><span class="line">    <span class="meta">@RequestMapping</span>(value = <span class="string">"/hello"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">(@RequestParam(value = <span class="string">"name"</span>)</span> String name)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>name：远程服务名即spring.application.name配置的名称</li>
<li>此类中的方法和远程服务中contoller中的方法名和参数需保持一致。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 远程服务controller</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloController</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/hello"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">index</span><span class="params">(@RequestParam String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"hello "</span>+name+<span class="string">"，this is first messge"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>web层调用远程服务</li>
</ul>
<p>将接口注入到controller层，像普通方法一样去调用即可。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConsumerController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    HelloRemote HelloRemote;</span><br><span class="line">	</span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/hello/&#123;name&#125;"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">index</span><span class="params">(@PathVariable(<span class="string">"name"</span>)</span> String name) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> HelloRemote.hello(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="服务治理机制"><a href="#服务治理机制" class="headerlink" title="服务治理机制"></a>服务治理机制</h4><p><img src="/2019/07/22/Spring Cloud/服务治理.jpg" alt="服务治理"></p>
<h5 id="服务提供者"><a href="#服务提供者" class="headerlink" title="服务提供者"></a>服务提供者</h5><h6 id="服务注册"><a href="#服务注册" class="headerlink" title="服务注册"></a>服务注册</h6><p>“服务提供者”在启动的时候会通过发送REST请求的方式将自己注册到Eureka Server上，同时带上了自身服务的一些元数据信息。Eureka Server接收到这个REST请求之后，将元数据信息存储在一个双层结构Map中，其中第一层的key是服务名，第二层的key是具体服务的实例名(一个服务可以用多个实例，这些内容都是以双层的Map形式存储的)</p>
<h6 id="服务同步"><a href="#服务同步" class="headerlink" title="服务同步"></a>服务同步</h6><p>如上图架构图所示，这里的两个服务提供者分别注册到了两个不同的服务注册中心上，也就是说，它们的信息分别被两个服务注册中心所维护。此时，由于服务注册中心之间因为互相注册为服务，当服务提供者发送注册请求到一个服务注册中心时，它会将该请求转发给集群中相连的其他注册中心，从而实现注册中心之间的服务同步。通过服务同步，两个服务提供者的服务信息就可以通过这两台服务注册中心中的任意一台获取到。</p>
<h6 id="服务续约"><a href="#服务续约" class="headerlink" title="服务续约"></a>服务续约</h6><p>在注册完服务之后，服务提供者会维护一个心跳用来持续高速Eureka Server”我还活着“，以防止Server剔除任务将该服务实例从服务列表中排除出去，我们称之为服务续约(Renew)</p>
<h5 id="服务消费者"><a href="#服务消费者" class="headerlink" title="服务消费者"></a>服务消费者</h5><h6 id="获取服务"><a href="#获取服务" class="headerlink" title="获取服务"></a>获取服务</h6><p>启动服务消费者的时候，会发送一个REST请求给服务注册中心，来获取上面注册的服务清单。</p>
<h6 id="服务调用"><a href="#服务调用" class="headerlink" title="服务调用"></a>服务调用</h6><p>获取服务清单之后，通过服务名可以获得具体提供服务的实例名和该实例的元数据信息，所以客户端可以根据自己的需要选择调用的实例。</p>
<p>对于实例的选择，Eureka中有Region和Zone的概念，一个Region中可以包含多个Zone，每个服务客户端需要被注册到一个Zone中，所以每个客户端对应一个Region和一个Zone。在服务调用的时候，优先访问同处一个Zone中的服务提供方，若访问不到，就访问其他的Zone。</p>
<h6 id="服务下线"><a href="#服务下线" class="headerlink" title="服务下线"></a>服务下线</h6><p>在客户端程序中，当服务实例进行正常的关闭操作时，会触发一个服务下线的REST请求给Eureka Server，服务端在接收到请求之后，将该服务状态置为下线(down)，并把该下线事件传播出去。</p>
<h5 id="服务注册中心"><a href="#服务注册中心" class="headerlink" title="服务注册中心"></a>服务注册中心</h5><h6 id="失效剔除"><a href="#失效剔除" class="headerlink" title="失效剔除"></a>失效剔除</h6><p>将一些无法提供服务的实例剔除，Eureka Server在启动的时候会创建一个定时任务，默认每隔一段时间(默认60s)将当前清单中超时(90s)没有续约的服务剔除出去。</p>
<h6 id="自我保护"><a href="#自我保护" class="headerlink" title="自我保护"></a>自我保护</h6><p>注册中心的信息面板上有一个红色的警告信息，就是触法了自我保护机制。在运行期间，会统计心跳失败的比例在15分钟内是否低于85%(单机调试的情况很好满足，但实际生产环境通常是因为网络不稳定)，如果出现低的情况就会触发自我保护机制，将当前的实例注册信息保护起来，让这些实例不会过期，但是，在这段保护期间内实例若出现问题，那么客户端很容易拿到实际已经不存在的服务实例，出现调用失败的情况，所以客户端要有容错机制，比如可以使用请求重试、断路器等机制。</p>
<p>+++</p>
<h3 id="Hystrix-熔断器"><a href="#Hystrix-熔断器" class="headerlink" title="Hystrix(熔断器)"></a>Hystrix(熔断器)</h3><p>处理服务的熔断防止故障扩散。Hystrix具备服务降级、服务熔断、线程和信号隔离、请求缓存、请求合并以及服务监控等强大功能。</p>
<h4 id="雪崩效应"><a href="#雪崩效应" class="headerlink" title="雪崩效应"></a>雪崩效应</h4><p>是一种因“服务提供者”的不可用导致“服务消费者”的不可用，并将不可用逐渐放大的过程。</p>
<p>例如微服务A调用微服务B和微服务C，微服务B和微服务C又调用其他的微服务，如果扇出的链路上某个微服务的响应时间过程或者不可用，对微服务A的调用就会占用越来越多的系统资源，造成系统崩溃。</p>
<hr>
<p>特性：断路器机制、Fallback、资源隔离：通过线程池来实现资源隔离，在使用时会根据调用的远程服务划分出多个线程池，这样运行环境被隔离开了，这样就算调用服务的代码存在bug或者由于其他原因导致自己所在线程池被耗尽时，不会对系统的其他服务造成影响。</p>
<p>熔断只是作用在服务调用这一端。</p>
<p>Feign中的Hystrix默认关闭，因为开发者可能不想在客户端中使用断路器，但只是通过使用Feign来获取断路器。 选择加入方法会更加理想，用户必须在其应用程序中为其FeignClient启用Hystrix。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">feign:</span></span><br><span class="line"><span class="attr">  hystrix:</span></span><br><span class="line"><span class="attr">    enabled:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<p>Hystrix的依赖隔离，是给每个依赖服务创建一个独立的线程池，会产生额外的消耗延迟，但这个消耗延迟对于灵活性和健壮性的增长是可以接受的，那么对于小部分延迟本身就非常小的请求，这个开销还是非常昂贵的，这个时候可以使用信号量来控制单个依赖服务的并发度，信号量的开销远比线程池要小，但是不能设置超时访问和实现异步访问，所以只用在少数依赖服务足够可靠的情况。</p>
<p>fallback方法是Hystrix命令执行失败时使用的后备方法，用来实现服务的降级处理逻辑。</p>
<h3 id="Spring-Cloud-Config"><a href="#Spring-Cloud-Config" class="headerlink" title="Spring Cloud Config"></a>Spring Cloud Config</h3><ul>
<li>提供服务端和客户端支持</li>
<li>集中管理各种环境的配置文件</li>
<li>配置文件修改之后，可以快速的生效</li>
<li>可以进行版本管理</li>
<li>支持大的并发查询</li>
<li>支持各种语言</li>
</ul>
<p>Spring Cloud Config项目是一个解决分布式系统的配置管理方案。它包括Client和Server两个部分，server提供配置文件的存储、以接口的形式将配置文件的内容提供出去，client通过接口获取数据、并依据此数据初始化自己的应用，Spring Cloud使用git或者svn存放配置文件，默认情况下使用git。</p>
<h3 id="zuul服务网关"><a href="#zuul服务网关" class="headerlink" title="zuul服务网关"></a>zuul服务网关</h3><p>在微服务架构中，后端服务不直接开放给调用端，而是通过一个API网关根据请求的url，路由到响应的服务。当添加API网关之后，在第三方调用端和服务提供方之间就创建了一面墙，这面墙直接与调用方通信进行权限控制，后将请求均衡分发给后台服务器。</p>
<p>使用API Gateway的原因是</p>
<ul>
<li><p>简化客户端调用复杂度</p>
</li>
<li><p>数据剪裁以及聚合</p>
<p>可以剪裁以适应不同客户端需求，也可以将多个API调用逻辑进行聚合，减少客户端的请求端，优化客户端用户体验。</p>
</li>
<li><p>多渠道支持</p>
</li>
<li><p>遗留系统的微服务化改造</p>
</li>
</ul>
<h4 id="zuul"><a href="#zuul" class="headerlink" title="zuul"></a>zuul</h4><p>Spring Cloud Zuul路由是微服务架构的不可或缺的一部分，提供动态路由，监控，弹性，安全等边缘服务，Zuul是Netflix出品的一个基于JVM路由和服务端的负载均衡器。</p>
<ol>
<li><p>加入zuul的依赖</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-zuul<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>在启动类中加入@EnableZuulProxy注解开启Zuul的API网关服务功能</p>
</li>
<li><p>在application.properties中配置Zuul应用的基础信息，如用户名、服务端口号等。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">spring.application.name=api-gateway</span><br><span class="line">server.port=5555</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h5 id="请求路由"><a href="#请求路由" class="headerlink" title="请求路由"></a>请求路由</h5><p>实现路由功能非常简单，只需要对api-gateway服务增加一些关于路由规则的配置，就能实现传统的路由转发功能。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">zuul.routes.api-a-url.path=/api-a-url/**</span><br><span class="line">zuul.routes.api-a-url.url=http://localhost:8080/</span><br></pre></td></tr></table></figure>
<p>该配置定义了发往API网关服务的请求中，所有符合/api-a-url/**规则的访问都将被路由转发到<a href="http://localhost:8080/地址上，当我们访问http://localhost:5555/api-a-url/hello的时候，API网关服务会将该请求路由到http://localhost:8080/hello提供的微服务接口上。配置属性zuul.routes.api-a-url.path中的api-a-url部分为路由的名字，可以任意定义，但是一组path和url映射关系的路由名要相同。" target="_blank" rel="noopener">http://localhost:8080/地址上，当我们访问http://localhost:5555/api-a-url/hello的时候，API网关服务会将该请求路由到http://localhost:8080/hello提供的微服务接口上。配置属性zuul.routes.api-a-url.path中的api-a-url部分为路由的名字，可以任意定义，但是一组path和url映射关系的路由名要相同。</a></p>
<h5 id="请求过滤"><a href="#请求过滤" class="headerlink" title="请求过滤"></a>请求过滤</h5><p>每个客户端用户请求微服务应用提供的接口时，它们的访问权限往往都有一定的限制，系统并不会将所有的微服务接口都对它们开放。最好的方法是通过前置的网关服务来完成这些非业务性质的校验。在请求到达的时候就完成校验和过滤，而不是转发之后再过滤而导致更长的请求延迟。Zuul允许开发者在API网关上通过定义过滤器来实现对请求的拦截和过滤，只需要继承ZuulFilter抽象类并实现它定义的4个抽象函数就可以完成对请求的拦截和过滤。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/07/11/Java并发容器和框架/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Saikikky Wang">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Saikikky">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/07/11/Java并发容器和框架/" itemprop="url">Java并发容器和框架</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-07-11T10:21:33+08:00">
                2019-07-11
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h3><pre><code>ConcurrentHashMap是由Segment数组结构和HashEntry数组结构组成。Segment是一种可重入锁(ReentrantLock)，在ConcurrentHashMap里扮演锁的角色；Segment的结构和HashEntry类似，是一种数组和链表结构，一个Segment里面包含一个HashEntry数组，每个HashEntry是一个链表结构的元素，每个Segment守护着一个HashEntry数组里的元素，当对HashEntry数组的数据进行修改时，必须首先获得与它对应的Segment锁。
</code></pre><ul>
<li>初始化</li>
</ul>
<p>segments数组的长度ssize是通过concurrencyLevel计算得出的，为了能通过按位与的散列算法来定位segments数组的索引，必须保证segments数组的长度是2的N次方，所以必须计算出一个大于或等于从currencyLevel的最小的2的N次方来作为segments数组的长度。(concurrencyLevel的最大值是65535，这意味着segments数组的长度最大为65536，对应的二进制是16位)。</p>
<ul>
<li>定位Segment</li>
</ul>
<p>在插入和获取元素的时候，必须先通过散列算法定位到Segment。</p>
<ul>
<li>get操作</li>
</ul>
<p>经过一次再散列，然后使用这个散列值通过散列运算定位到Segment，再通过散列算法定位到元素。get过程不需要加锁，除非读到的值是空才会加锁重读。原因是它的get方法里将要使用的共享变量都定义成volatile类型，比如用于统计当前Segment大小的count字段和用于存储值的HashEntry的value。定义成volatile的变量，能够在线程之间保持可见性，能够被多线程同时读，并且保证不会读到过期的值，但是只能被单线程写(有一种情况可以被多线程写，就是写入的值不依赖于原值)，<strong><em><u>由于Java内存模型的happen before原则，对volatile字段的写入操作咸鱼读操作，即使两个线程同时修改和获取volatile变量，get操作也能拿到最新的值，这是用volatile替换锁的经典应用场景。</u></em></strong></p>
<p>定位HashEntry和定位Segment的散列算法虽然一样，都与数组的长度减去1再相“与”，但是相“与”的值不一样，定位Segment使用的是元素的hashcode通过再散列后得到的值的高位，而定位HashEntry直接使用的是再散列后的值。其目的是避免两次散列后的值一样，虽然元素在Segment里散列开了，但是却没有在HashEntry中散开。</p>
<ul>
<li><p>put操作</p>
<ul>
<li><p>判断是否需要扩容</p>
<p>在插入元素之前判断Segment里的HashEntry数组是否超过容量。Segment的扩容比HashMap更恰当，HashMap是在插入元素后判断元素是否已经到达容量，如果到达就扩容，但是很有可能扩容之后就没有新元素插入，就进行了一次无效的扩容。</p>
</li>
<li><p>如何扩容</p>
<p>在扩容的时候，首先会创建一个容量是原来两倍的数组，然后将原数组里的元素进行再散列后再插入到新的数组种，为了高效只会对某个segment进行扩容。（会将这个segment的某一个entry中的值取余，比如余1的放在扩容前的位置，余0的放在扩容后的相应的位置）。</p>
</li>
</ul>
</li>
<li><p>size操作</p>
<p>Segment里的全局变量count是一个volatile变量，在多线程条件下，并不能直接把Segment里的count想加就可以得到整个ConcurrentHashMap大小。虽然相加时可以获得每个Segment的count的最新值，但是可能累加前使用的count发生了变化，那统计结果就不准了。全部锁住的方法太低效，但是累加过的count发生变化的几率非常小，所以ConcurrentHashMap的做法是先尝试2次通过不锁住Segment的方式来统计各个Segment的大小，如果统计的过程中，容器的count发生了变化，则再采用加锁的方式来统计所有Segment的大小。</p>
<p>如何判断在统计的时候容器是否发生了变化？使用modCount变量，在put、remove和clean方法里操作元素前都会将变量modCount进行加1，那么在统计size前后比较modCount是否发生变化，从而得知容器的大小是否发生变化。</p>
</li>
</ul>
<hr>
<h3 id="线程安全的队列"><a href="#线程安全的队列" class="headerlink" title="线程安全的队列"></a>线程安全的队列</h3><ul>
<li><p>阻塞算法：队列可以用一个锁(入队出队一个锁)或者两个锁(入队和出队用不同的锁)</p>
</li>
<li><p>非阻塞算法：使用循环CAS的方式实现 ConcurrentLinkedQueue</p>
<p>ConcurrentLinkedQueue是一个基于链接节点的无界线程安全队列，它采用先进先出的规则对节点进行排序，当我们添加一个元素的时候，它会添加到队列的尾部；当我们获取一个元素的时候，它会返回队列头部的元素。它采用了“wait-free“算法(即CAS算法)来实现。</p>
</li>
</ul>
<h4 id="阻塞队列"><a href="#阻塞队列" class="headerlink" title="阻塞队列"></a>阻塞队列</h4><p>阻塞队列是一个支持两个附加操作的队列，这两个附加操作支持阻塞的插入和移除方法。</p>
<ol>
<li>支持阻塞的插入方法：当队列满时，队列会阻塞插入元素的线程，直到队列不满。</li>
<li>支持阻塞的移除方法：在队列为空时，获取元素的线程会等待队列变为非空。</li>
</ol>
<p>阻塞队列经常用于生产者和消费者的场景，生产者是向队列里添加元素的线程，消费者则是取元素的线程，阻塞队列就是生产者用来存放元素、消费者用来获取元素的容器。(7种阻塞队列)</p>
<p><strong>实现原理</strong></p>
<p>使用通知模式实现，就是当生产者往满的队列里添加元素时会阻塞住生产者，当消费者消费了一个队列中的元素后，会通知生产者当前队列可用。</p>
<hr>
<h3 id="Fork-Join框架"><a href="#Fork-Join框架" class="headerlink" title="Fork/Join框架"></a>Fork/Join框架</h3><p>Fork/Join框架是Java7提供的一个用于并行执行任务的框架，是一个把大任务分割成若干个小任务，最终汇总每个小任务结果后得到大任务结果的框架。Fork就是把一个大任务切分为若干子任务并行的执行，Join就是合并这些子任务的执行结果，最后得到这个大任务的结果。</p>
<h4 id="工作窃取算法"><a href="#工作窃取算法" class="headerlink" title="工作窃取算法"></a>工作窃取算法</h4><p>某个线程从其他队列里窃取任务来执行。将一个大任务分成互不依赖的子任务，为了减少线程间的竞争，把这些子任务分别放到不同的队列里，并为每个队列创建一个单独的线程来执行队列里的任务，线程和队列一一对应。但有的线程会把自己的任务先干完，而其他线程对应的队列里还有任务等待处理，就去其他线程的队伍里窃取一个任务来执行，这时他们会访问同一个队列，所以为了减少窃取任务线程和被窃取任务线程之间的竞争，通常会使用双端队列，被窃取的任务线程永远从双端队列的头部拿任务执行，而窃取任务的线程永远从双端队列的尾部拿任务执行。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/07/09/Condition/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Saikikky Wang">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Saikikky">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/07/09/Condition/" itemprop="url">Condition</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-07-09T15:17:01+08:00">
                2019-07-09
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>本文来自：<a href="http://blog.csdn.net/ghsau" target="_blank" rel="noopener">高爽|Coder</a>，原文地址：<a href="http://blog.csdn.net/ghsau/article/details/7481142，转载请注明。" target="_blank" rel="noopener">http://blog.csdn.net/ghsau/article/details/7481142，转载请注明。</a></p>
<p><strong><em>Condition 将 Object 监视器方法（wait、notify 和 notifyAll）分解成截然不同的对象，以便通过将这些对象与任意 Lock 实现组合使用，为每个对象提供多个等待 set （wait-set）。其中，Lock 替代了 synchronized 方法和语句的使用，Condition 替代了 Object 监视器方法的使用</em></strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadTest2</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">final</span> Business business = <span class="keyword">new</span> Business();</span><br><span class="line">		<span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">				threadExecute(business, <span class="string">"sub"</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;).start();</span><br><span class="line">		threadExecute(business, <span class="string">"main"</span>);</span><br><span class="line">	&#125;	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">threadExecute</span><span class="params">(Business business, String threadType)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				<span class="keyword">if</span>(<span class="string">"main"</span>.equals(threadType)) &#123;</span><br><span class="line">					business.main(i);</span><br><span class="line">				&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">					business.sub(i);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Business</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">boolean</span> bool = <span class="keyword">true</span>;</span><br><span class="line">	<span class="keyword">private</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">	<span class="keyword">private</span> Condition condition = lock.newCondition(); </span><br><span class="line">	<span class="keyword">public</span> <span class="comment">/*synchronized*/</span> <span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> loop)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">		lock.lock();</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="keyword">while</span>(bool) &#123;				</span><br><span class="line">				condition.await();<span class="comment">//this.wait();</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">				System.out.println(<span class="string">"main thread seq of "</span> + i + <span class="string">", loop of "</span> + loop);</span><br><span class="line">			&#125;</span><br><span class="line">			bool = <span class="keyword">true</span>;</span><br><span class="line">			condition.signal();<span class="comment">//this.notify();</span></span><br><span class="line">		&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">			lock.unlock();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;	</span><br><span class="line">	<span class="keyword">public</span> <span class="comment">/*synchronized*/</span> <span class="function"><span class="keyword">void</span> <span class="title">sub</span><span class="params">(<span class="keyword">int</span> loop)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">		lock.lock();</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="keyword">while</span>(!bool) &#123;</span><br><span class="line">				condition.await();<span class="comment">//this.wait();</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">				System.out.println(<span class="string">"sub thread seq of "</span> + i + <span class="string">", loop of "</span> + loop);</span><br><span class="line">			&#125;</span><br><span class="line">			bool = <span class="keyword">false</span>;</span><br><span class="line">			condition.signal();<span class="comment">//this.notify();</span></span><br><span class="line">		&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">			lock.unlock();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在Condition中，用await()替换wait()，用signal()替换notify()，用signalAll()替换notifyAll()，传统线程的通信方式，Condition都可以实现，这里注意，Condition是被绑定到Lock上的，要创建一个Lock的Condition必须用newCondition()方法。这样看来，Condition和传统的线程通信没什么区别，Condition的强大之处在于它可以为多个线程间建立不同的Condition，下面引入API中的一段代码，加以说明。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BoundedBuffer</span> </span>&#123;</span><br><span class="line">   <span class="keyword">final</span> Lock lock = <span class="keyword">new</span> ReentrantLock();<span class="comment">//锁对象</span></span><br><span class="line">   <span class="keyword">final</span> Condition notFull  = lock.newCondition();<span class="comment">//写线程条件 </span></span><br><span class="line">   <span class="keyword">final</span> Condition notEmpty = lock.newCondition();<span class="comment">//读线程条件 </span></span><br><span class="line"> </span><br><span class="line">   <span class="keyword">final</span> Object[] items = <span class="keyword">new</span> Object[<span class="number">100</span>];<span class="comment">//缓存队列</span></span><br><span class="line">   <span class="keyword">int</span> putptr<span class="comment">/*写索引*/</span>, takeptr<span class="comment">/*读索引*/</span>, count<span class="comment">/*队列中存在的数据个数*/</span>;</span><br><span class="line"> </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(Object x)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">     lock.lock();</span><br><span class="line">     <span class="keyword">try</span> &#123;</span><br><span class="line">       <span class="keyword">while</span> (count == items.length)<span class="comment">//如果队列满了 </span></span><br><span class="line">         notFull.await();<span class="comment">//阻塞写线程</span></span><br><span class="line">       items[putptr] = x;<span class="comment">//赋值 </span></span><br><span class="line">       <span class="keyword">if</span> (++putptr == items.length) putptr = <span class="number">0</span>;<span class="comment">//如果写索引写到队列的最后一个位置了，那么置为0</span></span><br><span class="line">       ++count;<span class="comment">//个数++</span></span><br><span class="line">       notEmpty.signal();<span class="comment">//唤醒读线程</span></span><br><span class="line">     &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">       lock.unlock();</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   <span class="function"><span class="keyword">public</span> Object <span class="title">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">     lock.lock();</span><br><span class="line">     <span class="keyword">try</span> &#123;</span><br><span class="line">       <span class="keyword">while</span> (count == <span class="number">0</span>)<span class="comment">//如果队列为空</span></span><br><span class="line">         notEmpty.await();<span class="comment">//阻塞读线程</span></span><br><span class="line">       Object x = items[takeptr];<span class="comment">//取值 </span></span><br><span class="line">       <span class="keyword">if</span> (++takeptr == items.length) takeptr = <span class="number">0</span>;<span class="comment">//如果读索引读到队列的最后一个位置了，那么置为0</span></span><br><span class="line">       --count;<span class="comment">//个数--</span></span><br><span class="line">       notFull.signal();<span class="comment">//唤醒写线程</span></span><br><span class="line">       <span class="keyword">return</span> x;</span><br><span class="line">     &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">       lock.unlock();</span><br><span class="line">     &#125;</span><br><span class="line">   &#125; </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>这是一个处于多线程工作环境下的缓存区，缓存区提供了两个方法，put和take，put是存数据，take是取数据，内部有个缓存队列，具体变量和方法说明见代码，这个缓存区类实现的功能：有多个线程往里面存数据和从里面取数据，其缓存队列(先进先出后进后出)能缓存的最大数值是100，多个线程间是互斥的，当缓存队列中存储的值达到100时，将写线程阻塞，并唤醒读线程，当缓存队列中存储的值为0时，将读线程阻塞，并唤醒写线程，这也是ArrayBlockingQueue的内部实现。下面分析一下代码的执行过程.</p>
<ol>
<li><p>一个写线程执行，调用put方法；</p>
</li>
<li><p>判断count是否为100，显然没有100；</p>
</li>
<li><p>继续执行，存入值；</p>
</li>
<li><p>判断当前写入的索引位置++后，是否和100相等，相等将写入索引值变为0，并将count+1；</p>
</li>
<li><p>仅唤醒读线程阻塞队列中的一个；</p>
</li>
<li><p>一个读线程执行，调用take方法；</p>
</li>
<li><p>……</p>
</li>
<li><p>仅唤醒写线程阻塞队列中的一个。</p>
<p> 这就是多个Condition的强大之处，假设缓存队列中已经存满，那么阻塞的肯定是写线程，唤醒的肯定是读线程，相反，阻塞的肯定是读线程，唤醒的肯定是写线程，那么假设只有一个Condition会有什么效果呢，缓存队列中已经存满，这个Lock不知道唤醒的是读线程还是写线程了，如果唤醒的是读线程，皆大欢喜，如果唤醒的是写线程，那么线程刚被唤醒，又被阻塞了，这时又去唤醒，这样就浪费了很多时间。</p>
</li>
</ol>
<hr>
<p>任意一个Java对象都拥有一组监视器方法(Object上)，主要包括wait()、notify()、notifyAll()方法，与synchronized关键字配合使用，可以实现等待/通知模式。Condition接口也提供了类似Object监视器的方法。与Lock配合可以实现等待/通知模式。使用前要注意在调用方法前获取锁。</p>
<p>一般会将Condition对象作为成员变量。当调用await()方法后，当前线程会释放锁并在此等待。而其他线程调用Condition对象的signal()方法，通知当前线程之后，当前线程才从await()方法返回，并且在返回前已经获取了锁。</p>
<p>如果一个线程调用了Condition.await()方法，那么该线程将会释放锁、构造成节点加入等待队列并进入等待状态。节点饮用更新的过程并没有使用CAS保证，原因在于调用await()方法的线程必定是获取了锁的线程，也就是该过程是由锁来保证线程安全的。在Object监视器模型上，一个对象拥有一个同步队列和等待队列，而并发包中的Lock拥有一个同步队列和多个等待队列。Condition的实现是同步器的内部类，因此每个Condition实例都能访问同步器提供的方法，相当于每个Condition都拥有所属同步器的引用。</p>
<p>调用await()方法时，相当于是同步队列的首节点(获取了锁的节点)移动到Condition的等待队列中。同步队列的首节点并不是直接加入等待队列，而是通过addConditionWaiter()方法把当前线程构造成一个新的节点并将其加入等待队列中。</p>
<p>调用signal()方法，唤醒在等待队列中等待时间最长的节点(首节点)，在唤醒节点之前，会将节点移到同步队列中。调用该方法的前置条件是当前线程必须获取了锁，接着获取等待队列的首节点，并将其移动到同步队列并使用LockSupport唤醒节点中的线程。</p>
<p>被唤醒后的线程，将从await()方法中的while循环中退出，进而调用同步器的方法加入到获取同步状态的竞争中，成功获取同步状态(或者说锁)之后，被唤醒的线程将从先前调用的await()方法返回，此时该线程已经成功地获取了锁。</p>
<p>Condition的signalAll()方法，相当于对等待队列中的每个节点均执行一次signal()方法，效果就是将等待队列中所有节点全部移动到同步队列中，并唤醒每个节点的线程。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/07/02/锁——Lock接口/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Saikikky Wang">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Saikikky">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/07/02/锁——Lock接口/" itemprop="url">锁——Lock接口</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-07-02T20:48:03+08:00">
                2019-07-02
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="Lock接口"><a href="#Lock接口" class="headerlink" title="Lock接口"></a>Lock接口</h2><p>比synchronized关键字多了锁获取与释放的可操作性、可中断的获取锁以及超时获取锁等。获取到锁的线程能够响应中断，当获取到锁的线程被中断时，中断异常将会被抛出，同时锁会被释放。超时获取锁，在指定的截止时间之前获取锁，如果截止时间到了仍旧无法获取锁，则返回。</p>
<p>Lock接口的使用方式</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">lock.lock();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">  lock.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在finally块中释放锁，目的是保证在获取到锁之后，最终能够被释放。</p>
<h3 id="队列同步器AbstractQueuedSynchronizer"><a href="#队列同步器AbstractQueuedSynchronizer" class="headerlink" title="队列同步器AbstractQueuedSynchronizer"></a>队列同步器AbstractQueuedSynchronizer</h3><p>Lock接口的实现基本都是通过聚合了一个同步器的子类来完成线程访问控制的。</p>
<p>同步器用来构建锁或者其他同步组件的基础框架，使用一个int成员变量表示同步状态，通过<strong>内置的FIFO队列</strong>来完成资源获取线程的排队工作。</p>
<p>同步器主要使用方式是继承，子类被推荐定义为自动义同步组件的静态内部类，同步器自身并没有实现任何同步接口，它仅仅是定义了若干同步状态获取和释放的方法来供自定义组件使用，同步器既可以支持独占式地获取同步状态也可以支持共享式地获取同步状态，这样就可以方便实现不同类型的同步组件。(ReentrantLock、ReentrantReadWriteLock和CountDownLatch等)</p>
<ul>
<li><p>同步器与锁</p>
<p>锁是面向使用者的，它定义了使用者与锁交互的接口(比如可以允许两个线程并行访问)，隐藏了实现细节；同步器面向的是锁的实现者，简化锁的实现方式，屏蔽同步状态管理、线程的排队、等待和唤醒灯底层的操作。说白了，同步器就是实现锁的关键，利用同步器实现锁的语义。</p>
</li>
</ul>
<p>同步器的设计基于模板方法模式，使用者继承同步器并重写制定的方法，随后将同步器组合在自定义同步组件的实现中，并调用同步器提供的模版方法，而这些模版方法将会调用使用者重写的方法。</p>
<ul>
<li><p>独占式锁</p>
<p>在获取同步状态时，同步器维护一个同步队列，获取状态失败的线程都会被加入到队列中并在队列中进行自旋；移出队列(或停止自旋)的条件是前驱节点为头节点且成功获取了同步状态。在释放同步状态时，同步器调用tryRelease(int arg)方法释放同步状态，然后唤醒头节点的后继节点。</p>
</li>
<li><p>共享式同步锁</p>
<p>支持多个线程同时共享资源(读锁)，写锁为独占式访问。</p>
</li>
<li><p>独占式超时获取同步状态</p>
<p>流程与独占式锁类似，在未获取到同步状态时，会使当前线程等待nanosTimeout纳秒，如果当前线程在nanosTimeout纳秒内没有获取到同步状态，将会从等待逻辑中自动返回。(抛出中断异常)</p>
</li>
</ul>
<h3 id="重入锁ReentrantLock"><a href="#重入锁ReentrantLock" class="headerlink" title="重入锁ReentrantLock"></a>重入锁ReentrantLock</h3><p>支持重进入的锁，表示该锁能够支持一个线程对资源的重复加锁，此外，还支持获取锁时的公平和非公平性选择。(公平锁就是在绝对时间上，先对锁进行获取的请求一定先被满足，赋于等待时间最长的线程)(synchronized关键字隐式的支持重进入，比如一个synchronized修饰的递归方法，在方法执行时，执行线程在获取了锁之后仍能连续多次的获得该锁)</p>
<p>ReentrantLock将锁对象化</p>
<ul>
<li>判断是否有线程，或者某个特定线程，在排队等待获取锁。</li>
<li>带超时的获取锁的尝试</li>
<li>感知有没有成功获取到锁</li>
</ul>
<p><strong>重复获得多少次锁，释放的时候就要释放多少次，同步状态值</strong></p>
<p><strong>ReentrantLock和synchronized的区别</strong></p>
<ul>
<li>synchronized是关键字，ReentrantLock是类</li>
<li>ReentrantLock可以对获取锁的等待时间进行设置，避免死锁</li>
<li>ReentrantLock可以获取锁的各种信息</li>
<li>ReentrantLock可以灵活的实现多路通知</li>
<li>机制：ReentrantLock调用unsafe类的park()方法，sync操作Mark Word</li>
</ul>
<h3 id="读写锁ReentrantReadWriteLock"><a href="#读写锁ReentrantReadWriteLock" class="headerlink" title="读写锁ReentrantReadWriteLock"></a>读写锁ReentrantReadWriteLock</h3><p>读写锁在同一时刻可以允许多个读线程访问，不是排他锁。但是在写线程访问时，所有的读线程和其他线程均被阻塞。读写锁维护了一堆锁，一个读锁和一个写锁。</p>
<p><strong><em>遵循获取写锁、获取读锁再释放写锁的次序，写锁能够降级为读锁</em></strong></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/07/02/并发编程/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Saikikky Wang">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Saikikky">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/07/02/并发编程/" itemprop="url">并发编程</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-07-02T17:12:37+08:00">
                2019-07-02
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="suspend-、resume-、stop"><a href="#suspend-、resume-、stop" class="headerlink" title="suspend()、resume()、stop()"></a>suspend()、resume()、stop()</h3><p>​        之所以不建议使用，以suspend()为例，在调用之后，线程不会释放已经占有的资源(比如锁)，而是占有着资源进入睡眠模式，而是占有着资源进入睡眠模式，容易引发死锁问题。同样，stop()方法在终结一个线程时不会保证线程的资源正常释放，通常是没有给予线程完成资源释放工作的机会，因此会导致程序可能工作在不确定状态下。</p>
<h3 id="线程通信"><a href="#线程通信" class="headerlink" title="线程通信"></a>线程通信</h3><ul>
<li><p>volatile和synchronized关键字</p>
</li>
<li><p>等待/通知机制（wait、notify、notifyAll）</p>
</li>
<li><p>管道输入/输出流</p>
<p>管道输入/输出流和普通的文件输入/输出流或者网络输入/输出流不同之处在于，它主要用于线程之间的数据传输，而传输的媒介为内存。</p>
</li>
<li><p>Thread.join()</p>
</li>
<li><p>ThreadLocal</p>
<p>即线程变量，是一个以ThreadLocal对象为键、任意对象为值的存储结构。这个结构被附带在线程上，也就是说一个线程可以根据一个ThreadLocal对象查询到绑定在这个线程上的一个值。可以通过set(T)方法来设置一个值，在当前线程下再通过get()方法获取到原先设置的值。</p>
</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/06/13/锁的升级和对比/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Saikikky Wang">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Saikikky">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/06/13/锁的升级和对比/" itemprop="url">锁的升级和对比</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-06-13T15:49:22+08:00">
                2019-06-13
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="锁的状态"><a href="#锁的状态" class="headerlink" title="锁的状态"></a>锁的状态</h3><p>​    锁一共有4种状态，级别从低到高依次是：无锁状态、偏向锁状态、轻量级锁状态和重量级锁状态。锁可以升级但不能降级，目的是为了提高获得锁和释放锁的效率。</p>
<p><strong>1.偏向锁</strong></p>
<p>​    大多数情况下，锁不仅不存在多线程竞争，而且总是由同一线程获得，为了让线程获得锁的代价更低而引入了偏向锁。当一个线程访问同步块并获取锁时，会在对象头和栈帧中的锁记录里存储锁偏向的线程ID，以后该线程在进入和退出同步块时不需要进行CAS操作来加锁和解锁，只需测试对象头重是否存储着指向当前线程的偏向锁。测试失败则如果偏向锁标记为1，则尝试使用CAS将对象头的偏向锁指向当前线程。如果没有则使用CAS竞争锁。</p>
<p>​    若关闭偏向锁则程序默认进入轻量级锁状态。</p>
<p><strong>2.轻量级锁</strong></p>
<p><em>加锁</em></p>
<p>线程在执行同步块之前，JVM会先在当前线程的栈帧中创建用于存储锁记录的空间，并将对象头重的Mark Word复制到锁记录中(Displaced Mark Word)。然后线程尝试使用CAS将对象头中的Mark Word替换为指向锁记录的指针，如果成功线程获得锁，失败则表示其他线程竞争锁，当前线程便尝试使用自旋来获取锁。</p>
<p><em>解锁</em></p>
<p>解锁时会用原子的CAS操作将DIsplaced Mark Word替换回到对象头。如果成功表示没有竞争发生，如果失败，表示当前锁存在竞争，锁会膨胀成重量级锁。</p>
<p><strong>3.重量级锁</strong></p>
<p>自旋会消耗CPU，为了避免无用的自旋(比如获得锁的线程被阻塞住了)，一旦锁升级为重量级锁，就不会恢复到轻量级锁状态。在重量级锁状态下，其他线程试图获取锁时，都会被阻塞住，当持有锁的线程释放锁之后会唤醒这些线程，被唤醒的线程会再次争夺锁。</p>
<h3 id="原子操作-锁和CAS"><a href="#原子操作-锁和CAS" class="headerlink" title="原子操作(锁和CAS)"></a>原子操作(锁和CAS)</h3><blockquote>
<p>支持原子更新操作，适用于计数器、序列发生器等场景</p>
<p>属于乐观锁机制，号称lock-free</p>
<p>CAS操作失败时由开发者决定是否继续尝试，还是执行别的操作</p>
</blockquote>
<p><strong><em>PS:CAS操作</em></strong> 乐观锁</p>
<p>​    比较并交换：CAS操作需要输入两个数值，一个旧值(期望操作前的值)和一个新值，在操作期间先比较旧值有没有发生变化，如果没有发生变化，才叫换成新值，发生了变化则不交换，CAS使用版本号是因为为了解决ABA问题，一个值从A——&gt;B——&gt;A，检查，只能保证一个共享变量的原子操作，并发包中的AtomicReference类来保证引用对象之间的原子性，就可以把多个变量放在一个对象里来进行CAS操作。</p>
<ul>
<li><p>i++不是一个原子操作，i++是一个经典的读改写操作，i++也不是线程安全的，i++的过程是</p>
<p><strong>1.从内存中把i的值取出来放到CPU的寄存器中</strong></p>
<p><strong>2.CPU寄存器的值+1</strong></p>
<p><strong>3.把CPU寄存器的值写回内存</strong></p>
<p>对于读值，+1，写值这三步操作，在这三步任何之间都可能会有CPU调度产生，造成i的值被修改，造成脏读脏写。</p>
</li>
</ul>
<p><strong>Java中通过锁和循环CAS的方式来实现原子操作。其中循环CAS就是使用并发包中的一些类(Atomic+)，如AtomicBoolean(用原子方式更新的boolean值)、AtomicInteger(用原子方式更新的int值)和AtomicLong(用原子方式更新的long值)，还提供了有用的工具方法，比如以原子的方式将当前值自增1和自减1。</strong></p>
<p>JVM内部实现了偏向锁、轻量级锁和互斥锁，除了偏向锁，JVM实现锁的方式都用了循环CAS，即当一个线程想进入同步块的时候使用循环CAS的方式来获取锁，当退出同步块的时候使用循环CAS释放锁。</p>
<p><strong>CAS操作缺点</strong></p>
<ul>
<li><p>若循环时间长，则开销很大</p>
</li>
<li><p>只能保证一个共享变量的原子操作</p>
</li>
<li><p>ABA问题(即在对比预期值的过程中A变成了B又改回来成了A会默认没有改变可以进行更改)</p>
<p>通过AtomicStampedReference来进行版本控制可以解决这个问题 或者传统的互斥同步操作也可</p>
</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/06/03/常见SQL语句/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Saikikky Wang">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Saikikky">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/06/03/常见SQL语句/" itemprop="url">常见SQL语句</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-06-03T08:59:05+08:00">
                2019-06-03
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="常见语法"><a href="#常见语法" class="headerlink" title="常见语法"></a>常见语法</h3><h4 id="1-group-by"><a href="#1-group-by" class="headerlink" title="1.group by"></a>1.group by</h4><ul>
<li>满足“select子句中的列名必须为分组列或列函数。即要么是group by的列或者带有sum、count、max等函数的列且该条件只针对同一张表成立。(可以加入没有在group by里的其他表的列)</li>
<li>列函数对于group by子句定义的每个组各返回一个结果。</li>
</ul>
<h4 id="2-having"><a href="#2-having" class="headerlink" title="2.having"></a>2.having</h4><ul>
<li>通常与group by子句一起使用</li>
<li>where过滤行，having过滤组</li>
<li>出现在同一个sql的顺序：where&gt;group by&gt;having<ul>
<li>如果没有group by子句，having子句就跟where子句一样</li>
</ul>
</li>
</ul>
<blockquote>
<p><strong>查询平均成绩大于60分的同学的学号和平均成绩</strong></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; select student_id,avg(score) from score group by student_id having avg(score)&gt;60</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<p><strong>查询没有学全所有课的学生的学号、姓名</strong></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt; select stu.student_id,stu.name from student stu, score s </span><br><span class="line">&gt; where stu.student_id = s.student_id</span><br><span class="line">&gt; group by stu.student_id</span><br><span class="line">&gt; having count(*) &lt; (select count(*) from course)</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
</blockquote>
<p>+++</p>
<ul>
<li><p>现有学生表student(s_id, name)和借书表book(b_id, s_id)</p>
<p>要查找没有借书记录的学生信息</p>
</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> s_id <span class="keyword">from</span> student <span class="keyword">where</span> s_id <span class="keyword">not</span> <span class="keyword">in</span> (<span class="keyword">select</span> s_id <span class="keyword">from</span> book);</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> s_id <span class="keyword">from</span> student <span class="keyword">left</span> <span class="keyword">join</span> book <span class="keyword">on</span> student.s_id=book.s_id <span class="keyword">where</span> book.s_id=<span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> book <span class="keyword">where</span> (<span class="keyword">select</span> <span class="keyword">count</span>(<span class="number">1</span>) <span class="keyword">as</span> <span class="keyword">num</span> <span class="keyword">from</span> student <span class="keyword">where</span> student.s_id=book.s_id) = <span class="number">0</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>SQL Count(*)、group by、Having的联合使用</p>
<p>COUNT(*)  函数返回在给定的选择中被选的行数。</p>
<p>语法：SELECT  COUNT（*） FROM  table 返回总记录数</p>
<p>表app_category与表category关联。且表间关系是一对多，即同一个app_category_id 对应多个category-id,现在我需要统计出每一个category_id在app_category表中出现的次数那么该如何实现呢？</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> category_id, <span class="keyword">COUNT</span>(*) <span class="keyword">AS</span> <span class="keyword">count</span> <span class="keyword">from</span> app_category <span class="keyword">group</span> <span class="keyword">by</span> category_id;</span><br></pre></td></tr></table></figure>
<p>查询只有count的值大于2的时候 以id分组统计，查询分组后数量大于2的id和数量。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> category_id ,<span class="keyword">COUNT</span>(*) <span class="keyword">AS</span> <span class="keyword">count</span> <span class="keyword">FROM</span> app_category <span class="keyword">GROUP</span> <span class="keyword">BY</span> category_id <span class="keyword">HAVING</span> <span class="keyword">count</span>(category_id) &gt;<span class="number">2</span></span><br></pre></td></tr></table></figure>
<p>CARD 借书卡：          CNO 卡号，NAME 姓名，CLASS 班级</p>
<p>BOOKS 图书：           BNO 书号，BNAME 书名,AUTHOR 作者，PRICE 单价，QUANTITY 库存册数</p>
<p>BORROW 借书记录：  CNO 借书卡号，BNO 书号，RDATE 还书日期</p>
<p>找出借书超过5本的读者,输出借书卡号及所借图书册数</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> CNO,借图书册数=<span class="keyword">COUNT</span>(*)</span><br><span class="line"><span class="keyword">FROM</span> BORROW</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> CNO</span><br><span class="line"><span class="keyword">HAVING</span> <span class="keyword">COUNT</span>(*)&gt;<span class="number">5</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>like通配符</p>
<p>| 通配符 |                             说明                             |<br>| :—-: | :———————————————————-: |<br>|   _    |                      <strong>与任意字符匹配</strong>                      |<br>|   %    |                <strong>与包含一个或多个字符串匹配</strong>                |<br>|   []   | <strong>与特定范围</strong>(例如[a-d]或特定集例如[abcdef])中的任意字符串匹配<strong> |<br>|  [^]   | </strong>与特定范围（例如，[[^^a-f]]）或特定集（例如，[[^^abcdef]]）之外的任意单字符匹配。** |</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">查询id为100开头的学生信息</span><br><span class="line"><span class="keyword">Select</span> * fromStudent <span class="keyword">where</span> <span class="keyword">id</span> <span class="keyword">like</span> ‘<span class="number">100</span>%’;</span><br><span class="line"></span><br><span class="line">查询id为99结尾的学生信息</span><br><span class="line"><span class="keyword">Select</span> * <span class="keyword">from</span> Student <span class="keyword">where</span> <span class="keyword">id</span> <span class="keyword">like</span> ‘%<span class="number">99</span>’;</span><br><span class="line"></span><br><span class="line">查询id包含11在中间的学校信息</span><br><span class="line"><span class="keyword">Select</span>* <span class="keyword">from</span> Student <span class="keyword">where</span> <span class="keyword">id</span> <span class="keyword">like</span> %<span class="number">11</span>%;</span><br><span class="line"></span><br><span class="line">• WHERE name LIKE '_qiu' 可以找到所有三个字母的、以 qiu'结尾的名字（例如，xiaoqiu、daqiu）。 </span><br><span class="line">• WHERE name LIKE '% qiu'可以找到姓以qiu'结尾的所有员工。 </span><br><span class="line">• WHERE name LIKE '% qiu' %' 可以找到姓中任意位置包括qiu'的所有员工。 </span><br><span class="line">• WHERE name LIKE '[X] qiu'可以找到三个字母的、以qiu'结尾并以 X 开始的名字（即仅有 Xiaoqiu 和 Tim） </span><br><span class="line">• WHERE name LIKE x[^x]%' 可以找到以 x开始的、后面的（第二个）字母不为 x 的所有姓。</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p>max函数</p>
<p>查询现有图书中价格最高的图书，输出书名及作者</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> BNO,BNAME,AUTHOR <span class="keyword">FROM</span> BOOKS</span><br><span class="line"><span class="keyword">WHERE</span> PRICE=(</span><br><span class="line">    <span class="keyword">SELECT</span> <span class="keyword">MAX</span>(PRICE) <span class="keyword">FROM</span> BOOKS)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p>查询当前借了”计算方法”但没有借”计算方法习题集”的读者，输出其借书卡号，并按卡号降序排序输出</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> a.CNO</span><br><span class="line"><span class="keyword">FROM</span> BORROW a,BOOKS b</span><br><span class="line"><span class="keyword">WHERE</span> a.BNO=b.BNO <span class="keyword">AND</span> b.BNAME=N‘计算方法‘</span><br><span class="line">    <span class="keyword">AND</span> <span class="keyword">NOT</span> <span class="keyword">EXISTS</span>(</span><br><span class="line">        <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> BORROW aa,BOOKS bb</span><br><span class="line">        <span class="keyword">WHERE</span> aa.BNO=bb.BNO</span><br><span class="line">            <span class="keyword">AND</span> bb.BNAME=N‘计算方法习题集‘</span><br><span class="line">            <span class="keyword">AND</span> aa.CNO=a.CNO)</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> a.CNO <span class="keyword">DESC</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>将”C01”班同学所借图书的还期都延长一周</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> b <span class="keyword">SET</span> RDATE=<span class="keyword">DATEADD</span>(<span class="keyword">Day</span>,<span class="number">7</span>,b.RDATE)</span><br><span class="line"><span class="keyword">FROM</span> CARD a,BORROW b</span><br><span class="line"><span class="keyword">WHERE</span> a.CNO=b.CNO</span><br><span class="line">    <span class="keyword">AND</span> a.CLASS=N‘C01‘</span><br></pre></td></tr></table></figure>
</li>
<li><p>从BOOKS表中删除当前无人借阅的图书记录</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> A <span class="keyword">FROM</span> BOOKS a</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">NOT</span> <span class="keyword">EXISTS</span>(</span><br><span class="line">    <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> BORROW</span><br><span class="line">    <span class="keyword">WHERE</span> BNO=a.BNO)</span><br></pre></td></tr></table></figure>
</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">Saikikky Wang</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">22</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                
                  <span class="site-state-item-count">6</span>
                  <span class="site-state-item-name">tags</span>
                
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Saikikky Wang</span>

  
</div>



  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>




  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Mist</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
