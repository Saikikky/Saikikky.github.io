<!DOCTYPE html>



  


<html class="theme-next mist use-motion" lang>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">



  
  
    
    
  <script src="/lib/pace/pace.min.js?v=1.0.2"></script>
  <link href="/lib/pace/pace-theme-minimal.min.css?v=1.0.2" rel="stylesheet">







<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta property="og:type" content="website">
<meta property="og:title" content="Saikikky">
<meta property="og:url" content="http://yoursite.com/page/2/index.html">
<meta property="og:site_name" content="Saikikky">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Saikikky">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/page/2/">





  <title>Saikikky</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="default">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>
    
    <a href="https://github.com/Saikikky" class="github-corner" aria-label="View source on GitHub"><svg width="80" height="80" viewbox="0 0 250 250" style="fill:#151513; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"/><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"/><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"/></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Saikikky</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            Archives
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/07/29/搭建Spring Cloud Demo中遇到的问题/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Saikikky Wang">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Saikikky">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/07/29/搭建Spring Cloud Demo中遇到的问题/" itemprop="url">搭建Spring Cloud Demo中遇到的问题</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-07-29T08:59:05+08:00">
                2019-07-29
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <ol>
<li><p>SpringCloud无法引入@EnableFeignClients问题**</p>
<p>问题描述：</p>
<p>SpringBoot版本为2.1.6.RELEASE，Spring Cloud版本为Greenwich.SR2，在启动类上加@EnableFeignClients时，提示找不到响应的包，已经导入feign的依赖。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--引入feign--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-feign<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>版本不兼容问题，修改SpringBoot版本为1.5.13.RELEASE，Spring Cloude版本为Edgware.SR4后导入成功。(公司pom文件显示用的是1.5.11.RELEASE版本的SpringBoot和Edgware.RELEASE版本的Spring Cloud)</p>
</li>
<li><p><strong>服务消费者无法调用服务提供者的方法</strong></p>
<p>问题描述：</p>
<p>Eureka注册中心启动正常，服务提供者和服务调用者都成功注册到注册中心，其中注册中心端口号为8000，提供者端口号为9000，调用者端口号为9001。全部成功启动之后，直接调用服务提供者提供的方法可以成功访问，但通过调用者9001端口访问服务显示feign.RetryableException: Read timed out executing GET <a href="http://spring-cloud-producer/hello?name=s]" target="_blank" rel="noopener">http://spring-cloud-producer/hello?name=s]</a> with root cause错误，百度发现是超时问题修改了各种熔断 ribbon和feign配置都不起作用。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 同一实例最大重试次数，不包括首次调用。默认值为0</span></span><br><span class="line"><span class="string">ribbon.MaxAutoRetries=0</span></span><br><span class="line"><span class="comment"># 同一个微服务其他实例的最大重试次数，不包括第一次调用的实例。默认值为1</span></span><br><span class="line"><span class="string">ribbon.MaxAutoRetriesNextServer=0</span></span><br><span class="line"><span class="comment"># 是否所有操作（GET、POST等）都允许重试。默认值为false</span></span><br><span class="line"><span class="string">ribbon.OkToRetryOnAllOperations=false</span></span><br><span class="line"><span class="comment">## 设置连接超时时间</span></span><br><span class="line"><span class="string">ribbon.ConnectTimeout=60000</span></span><br><span class="line"><span class="comment">## 设置读取超时时间</span></span><br><span class="line"><span class="string">ribbon.ReadTimeout=60000</span></span><br><span class="line"><span class="comment">## 关闭feign的熔断</span></span><br><span class="line"><span class="string">feign.hystrix.enabled=false</span></span><br><span class="line"><span class="comment">## 用于禁用Hystrix的超时时间</span></span><br><span class="line"><span class="string">hystrix.command.default.execution.timeout.enabled=false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## 对所有操作请求都进行重试</span></span><br><span class="line"><span class="string">ribbon.OkToRetryOnAllOperations=true</span></span><br><span class="line"><span class="comment">## 切换实例的重试次数</span></span><br><span class="line"><span class="string">ribbon.MaxAutoRetriesNextServer=2</span></span><br><span class="line"><span class="comment">## 对当前实例的重试次数</span></span><br><span class="line"><span class="string">ribbon.MaxAutoRetries=1</span></span><br></pre></td></tr></table></figure>
<p>最后问题是8000端口无法访问？？但注册中心正常启动且服务提供端也可以正常启动  改成8080端口之后可以访问，重启电脑之后8000端口也可以访问，初步判断是端口占用的问题，但Eureka注册和服务器调用注册等的端口是如何工作的要再了解一下。</p>
<p>项目正常运行之后 通过netstat -anp tcp命令查看端口使用情况发现启用了五个127.0.0.1.8000 所以Eureka注册中心启动的时候究竟启动了几个怎么启动的需要看下。</p>
</li>
<li><p>设置FeignClient中的fallback不起作用，发现是没有打开feign对hystrix的支持。在配置文件中加入如下配置。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">feign:</span></span><br><span class="line"><span class="attr">  hystrix:</span></span><br><span class="line"><span class="attr">    enabled:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>
</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/07/22/Spring Cloud/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Saikikky Wang">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Saikikky">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/07/22/Spring Cloud/" itemprop="url">Spring Cloud</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-07-22T08:59:05+08:00">
                2019-07-22
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="Spring-Cloud"><a href="#Spring-Cloud" class="headerlink" title="Spring Cloud"></a>Spring Cloud</h2><h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>Spring Cloud不是云计算解决方案，而是在SpringBoot上构建的，用于快速构建分布式系统的通用模式的工具集。</p>
<p><strong><em>Spring Cloud是一个基于Spring Boot实现的云原生应用开发工具，它为基于JVM的云原生应用开发中涉及的配置管理、服务发现、熔断器、智能路由、微代理、控制总线、分布式会话和集群状态管理等操作提供了一种简单的开发方式。</em></strong></p>
<h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><ul>
<li>约定大于配置</li>
<li>适用于各种环境</li>
<li>隐藏了组件的复杂性，并提供声明式、无XML的配置方式</li>
<li>开箱即用，快速启动</li>
<li>组件丰富，功能齐全</li>
</ul>
<h4 id="核心子项目"><a href="#核心子项目" class="headerlink" title="核心子项目"></a>核心子项目</h4><p>微服务是可以独立部署、水平扩展、独立访问（或者有独立的数据库）的服务单元，SpringCloud就是这些微服务的大管家，采用了微服务这种架构之后，项目的数量会非常多，SpringCloud做为大管家需要管理好这些微服务，自然需要很多小弟来帮忙。</p>
<p>Netflix 与各种Netflix OSS组件集成，组成微服务的核心。</p>
<p>Config 配置管理工具，实现应用配置的外部化存储，支持客户端配置信息刷新、加密/解密配置内容等。</p>
<p>Bus 事件、消息总线，用于传播集群中的状态变化或事件，以及触发后续的处理。</p>
<p>Security等</p>
<h3 id="Eureka-服务中心"><a href="#Eureka-服务中心" class="headerlink" title="Eureka(服务中心)"></a>Eureka(服务中心)</h3><p>是一款提供服务注册和发现的产品。服务中心又叫注册中心，管理各种服务功能包括服务的注册、发现、熔断、负载、降级等，有了服务中心之后，所有调用都要通过服务中心去调用。</p>
<p>Eureka是一个基于REST的服务，主要在AWS云中使用，定位服务来进行中间层服务器的负载均衡和故障转移。</p>
<p>Eureka由两个组件组成：Eureka服务器和Eureka客户端。服务器用作服务注册服务器，客户端是一个Java客户端，用来简化与服务器的交互、作为轮询负载均衡器，并提供服务的故障切换支持。</p>
<p>Eureka Server提供服务注册和发现，Service Provider服务提供方，将自身服务注册到Eureka，从而使服务消费方能够找到，Service Consumer服务消费方，从Eureka获取注册服务列表，从而能够消费服务。</p>
<p>Eureka是Netflix服务发现的服务端与客户端，Eureka提供服务注册以及服务发现的能力，当是Eureka Server时(注册中心)，所有的客户端会向其注册，当是Eureka Client时，可以从注册中心获取对应的服务信息，或者是向Eureka Server将自己作为实例注册进去，每个Eureka不仅仅是一个服务端同时还是一个客户端。</p>
<p>当Eureka想要成为注册中心时，必须将注册中心的服务地址指向自己，同时禁用服务检索的功能。Eureka是一个高可用的组件，它没有后端缓存，每一个实例注册之后需要向注册中心发送心跳来检测服务的可用性，注册中心不处理请求的转发，只是记录每个实例注册进来的信息。</p>
<p>注册中心页面：<a href="http://localhost:8000/" target="_blank" rel="noopener">http://localhost:8000/</a></p>
<p>+++</p>
<p><strong>集群</strong></p>
<p>为了维持注册中心的高可用性，通常会使用集群，Eureka通过互相注册的方式来实现高可用的部署，所以只需要将Eureka Server配置其他可用的serviceUrl就可以实现高可用部署。</p>
<p>+++</p>
<p><strong>服务的提供与调用</strong></p>
<p>三个角色：服务注册中心、服务提供者和服务消费者。流程是首先启动注册中心，服务提供者生产服务并注册到服务中心中，消费者从服务中心中获取服务并执行。</p>
<ul>
<li>服务提供者的启动类上加上@EnableDiscoveryClient注解：能够让注册中心能够发现，扫描到该服务。</li>
</ul>
<p>@EnableDiscoveryClient和@EnableEurekaClient的区别是：后者只能用于Eureka做注册中心时，但前者也可以用于其他注册中心。</p>
<ul>
<li>服务消费者的启动类上加上@EnableFeignClients注解：启用feign进行远程调用。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Feign是一个声明式Web Service客户端。使用Feign能让编写Web Service客户端更加简单，它的使用方法是定义一个接口，然后在上面添加注解，同时也支持JAX-RS标准的注解。Feign也支持可拔插式的编码器和解码器。Spring Cloud对Feign进行了封装，使其支持Spring MVC标准注解和HttpMessageConverters。Feign可以与Eureka和Ribbon组合使用支持负载均衡。</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="Ribbon"><a href="#Ribbon" class="headerlink" title="Ribbon"></a>Ribbon</h4><p>服务消费者有两个目标分别是发现服务和消费服务，其中服务发现的任务由Eureka的客户端完成，服务消费的任务则由Ribbon完成。Ribbon是一个基于HTTP和TCP的客户端负载均衡器，可以在通过客户端中配置的ribbonServerList服务端列表去轮询访问以达到均衡负载的作用。当Ribbon和Eureka联合使用时，Ribbon的服务实例清单RibbonServerList会被DiscoveryEnabledNIWSServerList重写，扩展成从Eureka注册中心中获取服务端列表。</p>
<ul>
<li>服务提供者只需要启动多个服务实例并注册到一个注册中心或是多个相关联的服务注册中心。</li>
<li>服务消费者直接通过调用被@LoadBalanced注解修饰过的RestTemplate来实现面向服务的接口调用。</li>
</ul>
<p>Ribbon开启负载均衡，在启动类中加入如下方法和注解@LoadBalanced</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@LoadBalanced</span></span><br><span class="line"><span class="function">RestTemplate <span class="title">restTemplate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> RestTemplate();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//RestTemplate是Spring提供的用于访问Rest服务的客户端，RestTemplate提供了多种便捷访问远程Http服务的方法,能够大大提高客户端的编写效率。</span></span><br></pre></td></tr></table></figure>
<p>Spring Cloud Ribbon 通过LoadBalancerInterceptor拦截器对RestTemplate的请求进行拦截，并利用Spring Cloud的负载均衡器LoadBalancerClient将以逻辑服务名为host的URI转换成具体的服务实例地址的过程。</p>
<h5 id="客户端负载均衡"><a href="#客户端负载均衡" class="headerlink" title="客户端负载均衡"></a>客户端负载均衡</h5><p>负载均衡是对系统的高可用、网络压力的缓解和处理能力扩容的重要手段之一。一般的负载均衡指的是服务端的负载均衡，负责负载均衡的模块会维护一个下挂可用的服务端清单，通过心跳检测来保证清单中的都是可以用的服务器节点。而客户端的负载均衡和服务端的最大区别是服务清单所存储的位置，这些服务清单来源于注册中心，也需要心跳去维持服务端清单的健康性，只是需要和服务注册中心配合完成。</p>
<p>+++</p>
<h4 id="Feign"><a href="#Feign" class="headerlink" title="Feign"></a>Feign</h4><p>Spring Cloud Feign整合了Spring Cloud Ribbon和Spring Cloud Hystrix。帮助定义和实现依赖服务接口的定义，在Feign的实现下，只需创建一个接口并用注解的方式来配置它，即可完成对服务提供方的接口绑定。</p>
<ul>
<li><strong>Feign</strong>调用实现</li>
</ul>
<p>Feign支持服务的调用以及均衡负载。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FeignClient</span>(name= <span class="string">"spring-cloud-producer"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">HelloRemote</span> </span>&#123;</span><br><span class="line">    <span class="meta">@RequestMapping</span>(value = <span class="string">"/hello"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">(@RequestParam(value = <span class="string">"name"</span>)</span> String name)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>name：远程服务名即spring.application.name配置的名称</li>
<li>此类中的方法和远程服务中contoller中的方法名和参数需保持一致。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 远程服务controller</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloController</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/hello"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">index</span><span class="params">(@RequestParam String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"hello "</span>+name+<span class="string">"，this is first messge"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>web层调用远程服务</li>
</ul>
<p>将接口注入到controller层，像普通方法一样去调用即可。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConsumerController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    HelloRemote HelloRemote;</span><br><span class="line">	</span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/hello/&#123;name&#125;"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">index</span><span class="params">(@PathVariable(<span class="string">"name"</span>)</span> String name) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> HelloRemote.hello(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="服务治理机制"><a href="#服务治理机制" class="headerlink" title="服务治理机制"></a>服务治理机制</h4><p><img src="/Users/saikikky/Documents/专业学习/Blog/source/_posts/image/服务治理.jpg" alt="服务治理"></p>
<h5 id="服务提供者"><a href="#服务提供者" class="headerlink" title="服务提供者"></a>服务提供者</h5><h6 id="服务注册"><a href="#服务注册" class="headerlink" title="服务注册"></a>服务注册</h6><p>“服务提供者”在启动的时候会通过发送REST请求的方式将自己注册到Eureka Server上，同时带上了自身服务的一些元数据信息。Eureka Server接收到这个REST请求之后，将元数据信息存储在一个双层结构Map中，其中第一层的key是服务名，第二层的key是具体服务的实例名(一个服务可以用多个实例，这些内容都是以双层的Map形式存储的)</p>
<h6 id="服务同步"><a href="#服务同步" class="headerlink" title="服务同步"></a>服务同步</h6><p>如上图架构图所示，这里的两个服务提供者分别注册到了两个不同的服务注册中心上，也就是说，它们的信息分别被两个服务注册中心所维护。此时，由于服务注册中心之间因为互相注册为服务，当服务提供者发送注册请求到一个服务注册中心时，它会将该请求转发给集群中相连的其他注册中心，从而实现注册中心之间的服务同步。通过服务同步，两个服务提供者的服务信息就可以通过这两台服务注册中心中的任意一台获取到。</p>
<h6 id="服务续约"><a href="#服务续约" class="headerlink" title="服务续约"></a>服务续约</h6><p>在注册完服务之后，服务提供者会维护一个心跳用来持续高速Eureka Server”我还活着“，以防止Server剔除任务将该服务实例从服务列表中排除出去，我们称之为服务续约(Renew)</p>
<h5 id="服务消费者"><a href="#服务消费者" class="headerlink" title="服务消费者"></a>服务消费者</h5><h6 id="获取服务"><a href="#获取服务" class="headerlink" title="获取服务"></a>获取服务</h6><p>启动服务消费者的时候，会发送一个REST请求给服务注册中心，来获取上面注册的服务清单。</p>
<h6 id="服务调用"><a href="#服务调用" class="headerlink" title="服务调用"></a>服务调用</h6><p>获取服务清单之后，通过服务名可以获得具体提供服务的实例名和该实例的元数据信息，所以客户端可以根据自己的需要选择调用的实例。</p>
<p>对于实例的选择，Eureka中有Region和Zone的概念，一个Region中可以包含多个Zone，每个服务客户端需要被注册到一个Zone中，所以每个客户端对应一个Region和一个Zone。在服务调用的时候，优先访问同处一个Zone中的服务提供方，若访问不到，就访问其他的Zone。</p>
<h6 id="服务下线"><a href="#服务下线" class="headerlink" title="服务下线"></a>服务下线</h6><p>在客户端程序中，当服务实例进行正常的关闭操作时，会触发一个服务下线的REST请求给Eureka Server，服务端在接收到请求之后，将该服务状态置为下线(down)，并把该下线事件传播出去。</p>
<h5 id="服务注册中心"><a href="#服务注册中心" class="headerlink" title="服务注册中心"></a>服务注册中心</h5><h6 id="失效剔除"><a href="#失效剔除" class="headerlink" title="失效剔除"></a>失效剔除</h6><p>将一些无法提供服务的实例剔除，Eureka Server在启动的时候会创建一个定时任务，默认每隔一段时间(默认60s)将当前清单中超时(90s)没有续约的服务剔除出去。</p>
<h6 id="自我保护"><a href="#自我保护" class="headerlink" title="自我保护"></a>自我保护</h6><p>注册中心的信息面板上有一个红色的警告信息，就是触法了自我保护机制。在运行期间，会统计心跳失败的比例在15分钟内是否低于85%(单机调试的情况很好满足，但实际生产环境通常是因为网络不稳定)，如果出现低的情况就会触发自我保护机制，将当前的实例注册信息保护起来，让这些实例不会过期，但是，在这段保护期间内实例若出现问题，那么客户端很容易拿到实际已经不存在的服务实例，出现调用失败的情况，所以客户端要有容错机制，比如可以使用请求重试、断路器等机制。</p>
<p>+++</p>
<h3 id="Hystrix-熔断器"><a href="#Hystrix-熔断器" class="headerlink" title="Hystrix(熔断器)"></a>Hystrix(熔断器)</h3><p>处理服务的熔断防止故障扩散。Hystrix具备服务降级、服务熔断、线程和信号隔离、请求缓存、请求合并以及服务监控等强大功能。</p>
<h4 id="雪崩效应"><a href="#雪崩效应" class="headerlink" title="雪崩效应"></a>雪崩效应</h4><p>是一种因“服务提供者”的不可用导致“服务消费者”的不可用，并将不可用逐渐放大的过程。</p>
<p>例如微服务A调用微服务B和微服务C，微服务B和微服务C又调用其他的微服务，如果扇出的链路上某个微服务的响应时间过程或者不可用，对微服务A的调用就会占用越来越多的系统资源，造成系统崩溃。</p>
<hr>
<p>特性：断路器机制、Fallback、资源隔离：通过线程池来实现资源隔离，在使用时会根据调用的远程服务划分出多个线程池，这样运行环境被隔离开了，这样就算调用服务的代码存在bug或者由于其他原因导致自己所在线程池被耗尽时，不会对系统的其他服务造成影响。</p>
<p>熔断只是作用在服务调用这一端。</p>
<p>Feign中的Hystrix默认关闭，因为开发者可能不想在客户端中使用断路器，但只是通过使用Feign来获取断路器。 选择加入方法会更加理想，用户必须在其应用程序中为其FeignClient启用Hystrix。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">feign:</span></span><br><span class="line"><span class="attr">  hystrix:</span></span><br><span class="line"><span class="attr">    enabled:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<p>Hystrix的依赖隔离，是给每个依赖服务创建一个独立的线程池，会产生额外的消耗延迟，但这个消耗延迟对于灵活性和健壮性的增长是可以接受的，那么对于小部分延迟本身就非常小的请求，这个开销还是非常昂贵的，这个时候可以使用信号量来控制单个依赖服务的并发度，信号量的开销远比线程池要小，但是不能设置超时访问和实现异步访问，所以只用在少数依赖服务足够可靠的情况。</p>
<p>fallback方法是Hystrix命令执行失败时使用的后备方法，用来实现服务的降级处理逻辑。</p>
<h3 id="Spring-Cloud-Config"><a href="#Spring-Cloud-Config" class="headerlink" title="Spring Cloud Config"></a>Spring Cloud Config</h3><ul>
<li>提供服务端和客户端支持</li>
<li>集中管理各种环境的配置文件</li>
<li>配置文件修改之后，可以快速的生效</li>
<li>可以进行版本管理</li>
<li>支持大的并发查询</li>
<li>支持各种语言</li>
</ul>
<p>Spring Cloud Config项目是一个解决分布式系统的配置管理方案。它包括Client和Server两个部分，server提供配置文件的存储、以接口的形式将配置文件的内容提供出去，client通过接口获取数据、并依据此数据初始化自己的应用，Spring Cloud使用git或者svn存放配置文件，默认情况下使用git。</p>
<h3 id="zuul服务网关"><a href="#zuul服务网关" class="headerlink" title="zuul服务网关"></a>zuul服务网关</h3><p>在微服务架构中，后端服务不直接开放给调用端，而是通过一个API网关根据请求的url，路由到响应的服务。当添加API网关之后，在第三方调用端和服务提供方之间就创建了一面墙，这面墙直接与调用方通信进行权限控制，后将请求均衡分发给后台服务器。</p>
<p>使用API Gateway的原因是</p>
<ul>
<li><p>简化客户端调用复杂度</p>
</li>
<li><p>数据剪裁以及聚合</p>
<p>可以剪裁以适应不同客户端需求，也可以将多个API调用逻辑进行聚合，减少客户端的请求端，优化客户端用户体验。</p>
</li>
<li><p>多渠道支持</p>
</li>
<li><p>遗留系统的微服务化改造</p>
</li>
</ul>
<h4 id="zuul"><a href="#zuul" class="headerlink" title="zuul"></a>zuul</h4><p>Spring Cloud Zuul路由是微服务架构的不可或缺的一部分，提供动态路由，监控，弹性，安全等边缘服务，Zuul是Netflix出品的一个基于JVM路由和服务端的负载均衡器。</p>
<ol>
<li><p>加入zuul的依赖</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-zuul<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>在启动类中加入@EnableZuulProxy注解开启Zuul的API网关服务功能</p>
</li>
<li><p>在application.properties中配置Zuul应用的基础信息，如用户名、服务端口号等。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">spring.application.name=api-gateway</span><br><span class="line">server.port=5555</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h5 id="请求路由"><a href="#请求路由" class="headerlink" title="请求路由"></a>请求路由</h5><p>实现路由功能非常简单，只需要对api-gateway服务增加一些关于路由规则的配置，就能实现传统的路由转发功能。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">zuul.routes.api-a-url.path=/api-a-url/**</span><br><span class="line">zuul.routes.api-a-url.url=http://localhost:8080/</span><br></pre></td></tr></table></figure>
<p>该配置定义了发往API网关服务的请求中，所有符合/api-a-url/**规则的访问都将被路由转发到<a href="http://localhost:8080/地址上，当我们访问http://localhost:5555/api-a-url/hello的时候，API网关服务会将该请求路由到http://localhost:8080/hello提供的微服务接口上。配置属性zuul.routes.api-a-url.path中的api-a-url部分为路由的名字，可以任意定义，但是一组path和url映射关系的路由名要相同。" target="_blank" rel="noopener">http://localhost:8080/地址上，当我们访问http://localhost:5555/api-a-url/hello的时候，API网关服务会将该请求路由到http://localhost:8080/hello提供的微服务接口上。配置属性zuul.routes.api-a-url.path中的api-a-url部分为路由的名字，可以任意定义，但是一组path和url映射关系的路由名要相同。</a></p>
<h5 id="请求过滤"><a href="#请求过滤" class="headerlink" title="请求过滤"></a>请求过滤</h5><p>每个客户端用户请求微服务应用提供的接口时，它们的访问权限往往都有一定的限制，系统并不会将所有的微服务接口都对它们开放。最好的方法是通过前置的网关服务来完成这些非业务性质的校验。在请求到达的时候就完成校验和过滤，而不是转发之后再过滤而导致更长的请求延迟。Zuul允许开发者在API网关上通过定义过滤器来实现对请求的拦截和过滤，只需要继承ZuulFilter抽象类并实现它定义的4个抽象函数就可以完成对请求的拦截和过滤。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/07/11/Java并发容器和框架/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Saikikky Wang">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Saikikky">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/07/11/Java并发容器和框架/" itemprop="url">Java并发容器和框架</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-07-11T10:21:33+08:00">
                2019-07-11
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h3><pre><code>ConcurrentHashMap是由Segment数组结构和HashEntry数组结构组成。Segment是一种可重入锁(ReentrantLock)，在ConcurrentHashMap里扮演锁的角色；Segment的结构和HashEntry类似，是一种数组和链表结构，一个Segment里面包含一个HashEntry数组，每个HashEntry是一个链表结构的元素，每个Segment守护着一个HashEntry数组里的元素，当对HashEntry数组的数据进行修改时，必须首先获得与它对应的Segment锁。
</code></pre><ul>
<li>初始化</li>
</ul>
<p>segments数组的长度ssize是通过concurrencyLevel计算得出的，为了能通过按位与的散列算法来定位segments数组的索引，必须保证segments数组的长度是2的N次方，所以必须计算出一个大于或等于从currencyLevel的最小的2的N次方来作为segments数组的长度。(concurrencyLevel的最大值是65535，这意味着segments数组的长度最大为65536，对应的二进制是16位)。</p>
<ul>
<li>定位Segment</li>
</ul>
<p>在插入和获取元素的时候，必须先通过散列算法定位到Segment。</p>
<ul>
<li>get操作</li>
</ul>
<p>经过一次再散列，然后使用这个散列值通过散列运算定位到Segment，再通过散列算法定位到元素。get过程不需要加锁，除非读到的值是空才会加锁重读。原因是它的get方法里将要使用的共享变量都定义成volatile类型，比如用于统计当前Segment大小的count字段和用于存储值的HashEntry的value。定义成volatile的变量，能够在线程之间保持可见性，能够被多线程同时读，并且保证不会读到过期的值，但是只能被单线程写(有一种情况可以被多线程写，就是写入的值不依赖于原值)，<strong><em><u>由于Java内存模型的happen before原则，对volatile字段的写入操作咸鱼读操作，即使两个线程同时修改和获取volatile变量，get操作也能拿到最新的值，这是用volatile替换锁的经典应用场景。</u></em></strong></p>
<p>定位HashEntry和定位Segment的散列算法虽然一样，都与数组的长度减去1再相“与”，但是相“与”的值不一样，定位Segment使用的是元素的hashcode通过再散列后得到的值的高位，而定位HashEntry直接使用的是再散列后的值。其目的是避免两次散列后的值一样，虽然元素在Segment里散列开了，但是却没有在HashEntry中散开。</p>
<ul>
<li><p>put操作</p>
<ul>
<li><p>判断是否需要扩容</p>
<p>在插入元素之前判断Segment里的HashEntry数组是否超过容量。Segment的扩容比HashMap更恰当，HashMap是在插入元素后判断元素是否已经到达容量，如果到达就扩容，但是很有可能扩容之后就没有新元素插入，就进行了一次无效的扩容。</p>
</li>
<li><p>如何扩容</p>
<p>在扩容的时候，首先会创建一个容量是原来两倍的数组，然后将原数组里的元素进行再散列后再插入到新的数组种，为了高效只会对某个segment进行扩容。（会将这个segment的某一个entry中的值取余，比如余1的放在扩容前的位置，余0的放在扩容后的相应的位置）。</p>
</li>
</ul>
</li>
<li><p>size操作</p>
<p>Segment里的全局变量count是一个volatile变量，在多线程条件下，并不能直接把Segment里的count想加就可以得到整个ConcurrentHashMap大小。虽然相加时可以获得每个Segment的count的最新值，但是可能累加前使用的count发生了变化，那统计结果就不准了。全部锁住的方法太低效，但是累加过的count发生变化的几率非常小，所以ConcurrentHashMap的做法是先尝试2次通过不锁住Segment的方式来统计各个Segment的大小，如果统计的过程中，容器的count发生了变化，则再采用加锁的方式来统计所有Segment的大小。</p>
<p>如何判断在统计的时候容器是否发生了变化？使用modCount变量，在put、remove和clean方法里操作元素前都会将变量modCount进行加1，那么在统计size前后比较modCount是否发生变化，从而得知容器的大小是否发生变化。</p>
</li>
</ul>
<hr>
<h3 id="线程安全的队列"><a href="#线程安全的队列" class="headerlink" title="线程安全的队列"></a>线程安全的队列</h3><ul>
<li><p>阻塞算法：队列可以用一个锁(入队出队一个锁)或者两个锁(入队和出队用不同的锁)</p>
</li>
<li><p>非阻塞算法：使用循环CAS的方式实现 ConcurrentLinkedQueue</p>
<p>ConcurrentLinkedQueue是一个基于链接节点的无界线程安全队列，它采用先进先出的规则对节点进行排序，当我们添加一个元素的时候，它会添加到队列的尾部；当我们获取一个元素的时候，它会返回队列头部的元素。它采用了“wait-free“算法(即CAS算法)来实现。</p>
</li>
</ul>
<h4 id="阻塞队列"><a href="#阻塞队列" class="headerlink" title="阻塞队列"></a>阻塞队列</h4><p>阻塞队列是一个支持两个附加操作的队列，这两个附加操作支持阻塞的插入和移除方法。</p>
<ol>
<li>支持阻塞的插入方法：当队列满时，队列会阻塞插入元素的线程，直到队列不满。</li>
<li>支持阻塞的移除方法：在队列为空时，获取元素的线程会等待队列变为非空。</li>
</ol>
<p>阻塞队列经常用于生产者和消费者的场景，生产者是向队列里添加元素的线程，消费者则是取元素的线程，阻塞队列就是生产者用来存放元素、消费者用来获取元素的容器。(7种阻塞队列)</p>
<p><strong>实现原理</strong></p>
<p>使用通知模式实现，就是当生产者往满的队列里添加元素时会阻塞住生产者，当消费者消费了一个队列中的元素后，会通知生产者当前队列可用。</p>
<hr>
<h3 id="Fork-Join框架"><a href="#Fork-Join框架" class="headerlink" title="Fork/Join框架"></a>Fork/Join框架</h3><p>Fork/Join框架是Java7提供的一个用于并行执行任务的框架，是一个把大任务分割成若干个小任务，最终汇总每个小任务结果后得到大任务结果的框架。Fork就是把一个大任务切分为若干子任务并行的执行，Join就是合并这些子任务的执行结果，最后得到这个大任务的结果。</p>
<h4 id="工作窃取算法"><a href="#工作窃取算法" class="headerlink" title="工作窃取算法"></a>工作窃取算法</h4><p>某个线程从其他队列里窃取任务来执行。将一个大任务分成互不依赖的子任务，为了减少线程间的竞争，把这些子任务分别放到不同的队列里，并为每个队列创建一个单独的线程来执行队列里的任务，线程和队列一一对应。但有的线程会把自己的任务先干完，而其他线程对应的队列里还有任务等待处理，就去其他线程的队伍里窃取一个任务来执行，这时他们会访问同一个队列，所以为了减少窃取任务线程和被窃取任务线程之间的竞争，通常会使用双端队列，被窃取的任务线程永远从双端队列的头部拿任务执行，而窃取任务的线程永远从双端队列的尾部拿任务执行。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/07/09/Condition/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Saikikky Wang">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Saikikky">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/07/09/Condition/" itemprop="url">Condition</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-07-09T15:17:01+08:00">
                2019-07-09
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>本文来自：<a href="http://blog.csdn.net/ghsau" target="_blank" rel="noopener">高爽|Coder</a>，原文地址：<a href="http://blog.csdn.net/ghsau/article/details/7481142，转载请注明。" target="_blank" rel="noopener">http://blog.csdn.net/ghsau/article/details/7481142，转载请注明。</a></p>
<p><strong><em>Condition 将 Object 监视器方法（wait、notify 和 notifyAll）分解成截然不同的对象，以便通过将这些对象与任意 Lock 实现组合使用，为每个对象提供多个等待 set （wait-set）。其中，Lock 替代了 synchronized 方法和语句的使用，Condition 替代了 Object 监视器方法的使用</em></strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadTest2</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">final</span> Business business = <span class="keyword">new</span> Business();</span><br><span class="line">		<span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">				threadExecute(business, <span class="string">"sub"</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;).start();</span><br><span class="line">		threadExecute(business, <span class="string">"main"</span>);</span><br><span class="line">	&#125;	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">threadExecute</span><span class="params">(Business business, String threadType)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				<span class="keyword">if</span>(<span class="string">"main"</span>.equals(threadType)) &#123;</span><br><span class="line">					business.main(i);</span><br><span class="line">				&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">					business.sub(i);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Business</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">boolean</span> bool = <span class="keyword">true</span>;</span><br><span class="line">	<span class="keyword">private</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">	<span class="keyword">private</span> Condition condition = lock.newCondition(); </span><br><span class="line">	<span class="keyword">public</span> <span class="comment">/*synchronized*/</span> <span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> loop)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">		lock.lock();</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="keyword">while</span>(bool) &#123;				</span><br><span class="line">				condition.await();<span class="comment">//this.wait();</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">				System.out.println(<span class="string">"main thread seq of "</span> + i + <span class="string">", loop of "</span> + loop);</span><br><span class="line">			&#125;</span><br><span class="line">			bool = <span class="keyword">true</span>;</span><br><span class="line">			condition.signal();<span class="comment">//this.notify();</span></span><br><span class="line">		&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">			lock.unlock();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;	</span><br><span class="line">	<span class="keyword">public</span> <span class="comment">/*synchronized*/</span> <span class="function"><span class="keyword">void</span> <span class="title">sub</span><span class="params">(<span class="keyword">int</span> loop)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">		lock.lock();</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="keyword">while</span>(!bool) &#123;</span><br><span class="line">				condition.await();<span class="comment">//this.wait();</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">				System.out.println(<span class="string">"sub thread seq of "</span> + i + <span class="string">", loop of "</span> + loop);</span><br><span class="line">			&#125;</span><br><span class="line">			bool = <span class="keyword">false</span>;</span><br><span class="line">			condition.signal();<span class="comment">//this.notify();</span></span><br><span class="line">		&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">			lock.unlock();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在Condition中，用await()替换wait()，用signal()替换notify()，用signalAll()替换notifyAll()，传统线程的通信方式，Condition都可以实现，这里注意，Condition是被绑定到Lock上的，要创建一个Lock的Condition必须用newCondition()方法。这样看来，Condition和传统的线程通信没什么区别，Condition的强大之处在于它可以为多个线程间建立不同的Condition，下面引入API中的一段代码，加以说明。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BoundedBuffer</span> </span>&#123;</span><br><span class="line">   <span class="keyword">final</span> Lock lock = <span class="keyword">new</span> ReentrantLock();<span class="comment">//锁对象</span></span><br><span class="line">   <span class="keyword">final</span> Condition notFull  = lock.newCondition();<span class="comment">//写线程条件 </span></span><br><span class="line">   <span class="keyword">final</span> Condition notEmpty = lock.newCondition();<span class="comment">//读线程条件 </span></span><br><span class="line"> </span><br><span class="line">   <span class="keyword">final</span> Object[] items = <span class="keyword">new</span> Object[<span class="number">100</span>];<span class="comment">//缓存队列</span></span><br><span class="line">   <span class="keyword">int</span> putptr<span class="comment">/*写索引*/</span>, takeptr<span class="comment">/*读索引*/</span>, count<span class="comment">/*队列中存在的数据个数*/</span>;</span><br><span class="line"> </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(Object x)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">     lock.lock();</span><br><span class="line">     <span class="keyword">try</span> &#123;</span><br><span class="line">       <span class="keyword">while</span> (count == items.length)<span class="comment">//如果队列满了 </span></span><br><span class="line">         notFull.await();<span class="comment">//阻塞写线程</span></span><br><span class="line">       items[putptr] = x;<span class="comment">//赋值 </span></span><br><span class="line">       <span class="keyword">if</span> (++putptr == items.length) putptr = <span class="number">0</span>;<span class="comment">//如果写索引写到队列的最后一个位置了，那么置为0</span></span><br><span class="line">       ++count;<span class="comment">//个数++</span></span><br><span class="line">       notEmpty.signal();<span class="comment">//唤醒读线程</span></span><br><span class="line">     &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">       lock.unlock();</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   <span class="function"><span class="keyword">public</span> Object <span class="title">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">     lock.lock();</span><br><span class="line">     <span class="keyword">try</span> &#123;</span><br><span class="line">       <span class="keyword">while</span> (count == <span class="number">0</span>)<span class="comment">//如果队列为空</span></span><br><span class="line">         notEmpty.await();<span class="comment">//阻塞读线程</span></span><br><span class="line">       Object x = items[takeptr];<span class="comment">//取值 </span></span><br><span class="line">       <span class="keyword">if</span> (++takeptr == items.length) takeptr = <span class="number">0</span>;<span class="comment">//如果读索引读到队列的最后一个位置了，那么置为0</span></span><br><span class="line">       --count;<span class="comment">//个数--</span></span><br><span class="line">       notFull.signal();<span class="comment">//唤醒写线程</span></span><br><span class="line">       <span class="keyword">return</span> x;</span><br><span class="line">     &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">       lock.unlock();</span><br><span class="line">     &#125;</span><br><span class="line">   &#125; </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>这是一个处于多线程工作环境下的缓存区，缓存区提供了两个方法，put和take，put是存数据，take是取数据，内部有个缓存队列，具体变量和方法说明见代码，这个缓存区类实现的功能：有多个线程往里面存数据和从里面取数据，其缓存队列(先进先出后进后出)能缓存的最大数值是100，多个线程间是互斥的，当缓存队列中存储的值达到100时，将写线程阻塞，并唤醒读线程，当缓存队列中存储的值为0时，将读线程阻塞，并唤醒写线程，这也是ArrayBlockingQueue的内部实现。下面分析一下代码的执行过程.</p>
<ol>
<li><p>一个写线程执行，调用put方法；</p>
</li>
<li><p>判断count是否为100，显然没有100；</p>
</li>
<li><p>继续执行，存入值；</p>
</li>
<li><p>判断当前写入的索引位置++后，是否和100相等，相等将写入索引值变为0，并将count+1；</p>
</li>
<li><p>仅唤醒读线程阻塞队列中的一个；</p>
</li>
<li><p>一个读线程执行，调用take方法；</p>
</li>
<li><p>……</p>
</li>
<li><p>仅唤醒写线程阻塞队列中的一个。</p>
<p> 这就是多个Condition的强大之处，假设缓存队列中已经存满，那么阻塞的肯定是写线程，唤醒的肯定是读线程，相反，阻塞的肯定是读线程，唤醒的肯定是写线程，那么假设只有一个Condition会有什么效果呢，缓存队列中已经存满，这个Lock不知道唤醒的是读线程还是写线程了，如果唤醒的是读线程，皆大欢喜，如果唤醒的是写线程，那么线程刚被唤醒，又被阻塞了，这时又去唤醒，这样就浪费了很多时间。</p>
</li>
</ol>
<hr>
<p>任意一个Java对象都拥有一组监视器方法(Object上)，主要包括wait()、notify()、notifyAll()方法，与synchronized关键字配合使用，可以实现等待/通知模式。Condition接口也提供了类似Object监视器的方法。与Lock配合可以实现等待/通知模式。使用前要注意在调用方法前获取锁。</p>
<p>一般会将Condition对象作为成员变量。当调用await()方法后，当前线程会释放锁并在此等待。而其他线程调用Condition对象的signal()方法，通知当前线程之后，当前线程才从await()方法返回，并且在返回前已经获取了锁。</p>
<p>如果一个线程调用了Condition.await()方法，那么该线程将会释放锁、构造成节点加入等待队列并进入等待状态。节点饮用更新的过程并没有使用CAS保证，原因在于调用await()方法的线程必定是获取了锁的线程，也就是该过程是由锁来保证线程安全的。在Object监视器模型上，一个对象拥有一个同步队列和等待队列，而并发包中的Lock拥有一个同步队列和多个等待队列。Condition的实现是同步器的内部类，因此每个Condition实例都能访问同步器提供的方法，相当于每个Condition都拥有所属同步器的引用。</p>
<p>调用await()方法时，相当于是同步队列的首节点(获取了锁的节点)移动到Condition的等待队列中。同步队列的首节点并不是直接加入等待队列，而是通过addConditionWaiter()方法把当前线程构造成一个新的节点并将其加入等待队列中。</p>
<p>调用signal()方法，唤醒在等待队列中等待时间最长的节点(首节点)，在唤醒节点之前，会将节点移到同步队列中。调用该方法的前置条件是当前线程必须获取了锁，接着获取等待队列的首节点，并将其移动到同步队列并使用LockSupport唤醒节点中的线程。</p>
<p>被唤醒后的线程，将从await()方法中的while循环中退出，进而调用同步器的方法加入到获取同步状态的竞争中，成功获取同步状态(或者说锁)之后，被唤醒的线程将从先前调用的await()方法返回，此时该线程已经成功地获取了锁。</p>
<p>Condition的signalAll()方法，相当于对等待队列中的每个节点均执行一次signal()方法，效果就是将等待队列中所有节点全部移动到同步队列中，并唤醒每个节点的线程。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/07/02/锁/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Saikikky Wang">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Saikikky">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/07/02/锁/" itemprop="url">锁</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-07-02T20:48:03+08:00">
                2019-07-02
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="Lock接口"><a href="#Lock接口" class="headerlink" title="Lock接口"></a>Lock接口</h2><p>比synchronized关键字多了锁获取与释放的可操作性、可中断的获取锁以及超时获取锁等。获取到锁的线程能够响应中断，当获取到锁的线程被中断时，中断异常将会被抛出，同时锁会被释放。超时获取锁，在指定的截止时间之前获取锁，如果截止时间到了仍旧无法获取锁，则返回。</p>
<p>Lock接口的使用方式</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">lock.lock();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">  lock.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在finally块中释放锁，目的是保证在获取到锁之后，最终能够被释放。</p>
<h3 id="队列同步器AbstractQueuedSynchronizer"><a href="#队列同步器AbstractQueuedSynchronizer" class="headerlink" title="队列同步器AbstractQueuedSynchronizer"></a>队列同步器AbstractQueuedSynchronizer</h3><p>Lock接口的实现基本都是通过聚合了一个同步器的子类来完成线程访问控制的。</p>
<p>同步器用来构建锁或者其他同步组件的基础框架，使用一个int成员变量表示同步状态，通过<strong>内置的FIFO队列</strong>来完成资源获取线程的排队工作。</p>
<p>同步器主要使用方式是继承，子类被推荐定义为自动义同步组件的静态内部类，同步器自身并没有实现任何同步接口，它仅仅是定义了若干同步状态获取和释放的方法来供自定义组件使用，同步器既可以支持独占式地获取同步状态也可以支持共享式地获取同步状态，这样就可以方便实现不同类型的同步组件。(ReentrantLock、ReentrantReadWriteLock和CountDownLatch等)</p>
<ul>
<li><p>同步器与锁</p>
<p>锁是面向使用者的，它定义了使用者与锁交互的接口(比如可以允许两个线程并行访问)，隐藏了实现细节；同步器面向的是锁的实现者，简化锁的实现方式，屏蔽同步状态管理、线程的排队、等待和唤醒灯底层的操作。说白了，同步器就是实现锁的关键，利用同步器实现锁的语义。</p>
</li>
</ul>
<p>同步器的设计基于模板方法模式，使用者继承同步器并重写制定的方法，随后将同步器组合在自定义同步组件的实现中，并调用同步器提供的模版方法，而这些模版方法将会调用使用者重写的方法。</p>
<ul>
<li><p>独占式锁</p>
<p>在获取同步状态时，同步器维护一个同步队列，获取状态失败的线程都会被加入到队列中并在队列中进行自旋；移出队列(或停止自旋)的条件是前驱节点为头节点且成功获取了同步状态。在释放同步状态时，同步器调用tryRelease(int arg)方法释放同步状态，然后唤醒头节点的后继节点。</p>
</li>
<li><p>共享式同步锁</p>
<p>支持多个线程同时共享资源(读锁)，写锁为独占式访问。</p>
</li>
<li><p>独占式超时获取同步状态</p>
<p>流程与独占式锁类似，在未获取到同步状态时，会使当前线程等待nanosTimeout纳秒，如果当前线程在nanosTimeout纳秒内没有获取到同步状态，将会从等待逻辑中自动返回。(抛出中断异常)</p>
</li>
</ul>
<h3 id="重入锁ReentrantLock"><a href="#重入锁ReentrantLock" class="headerlink" title="重入锁ReentrantLock"></a>重入锁ReentrantLock</h3><p>支持重进入的锁，表示该锁能够支持一个线程对资源的重复加锁，此外，还支持获取锁时的公平和非公平性选择。(公平锁就是在绝对时间上，先对锁进行获取的请求一定先被满足)(synchronized关键字隐式的支持重进入，比如一个synchronized修饰的递归方法，在方法执行时，执行线程在获取了锁之后仍能连续多次的获得该锁)</p>
<p><strong>重复获得多少次锁，释放的时候就要释放多少次，同步状态值</strong></p>
<h3 id="读写锁ReentrantReadWriteLock"><a href="#读写锁ReentrantReadWriteLock" class="headerlink" title="读写锁ReentrantReadWriteLock"></a>读写锁ReentrantReadWriteLock</h3><p>读写锁在同一时刻可以允许多个读线程访问，不是排他锁。但是在写线程访问时，所有的读线程和其他线程均被阻塞。读写锁维护了一堆锁，一个读锁和一个写锁。</p>
<p><strong><em>遵循获取写锁、获取读锁再释放写锁的次序，写锁能够降级为读锁</em></strong></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/07/02/并发编程/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Saikikky Wang">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Saikikky">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/07/02/并发编程/" itemprop="url">并发编程</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-07-02T17:12:37+08:00">
                2019-07-02
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="suspend-、resume-、stop"><a href="#suspend-、resume-、stop" class="headerlink" title="suspend()、resume()、stop()"></a>suspend()、resume()、stop()</h3><p>​        之所以不建议使用，以suspend()为例，在调用之后，线程不会释放已经占有的资源(比如锁)，而是占有着资源进入睡眠模式，而是占有着资源进入睡眠模式，容易引发死锁问题。同样，stop()方法在终结一个线程时不会保证线程的资源正常释放，通常是没有给予线程完成资源释放工作的机会，因此会导致程序可能工作在不确定状态下。</p>
<h3 id="线程通信"><a href="#线程通信" class="headerlink" title="线程通信"></a>线程通信</h3><ul>
<li><p>volatile和synchronized关键字</p>
</li>
<li><p>等待/通知机制（wait、notify、notifyAll）</p>
</li>
<li><p>管道输入/输出流</p>
<p>管道输入/输出流和普通的文件输入/输出流或者网络输入/输出流不同之处在于，它主要用于线程之间的数据传输，而传输的媒介为内存。</p>
</li>
<li><p>Thread.join()</p>
</li>
<li><p>ThreadLocal</p>
<p>即线程变量，是一个以ThreadLocal对象为键、任意对象为值的存储结构。这个结构被附带在线程上，也就是说一个线程可以根据一个ThreadLocal对象查询到绑定在这个线程上的一个值。可以通过set(T)方法来设置一个值，在当前线程下再通过get()方法获取到原先设置的值。</p>
</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/06/13/锁的升级和对比/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Saikikky Wang">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Saikikky">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/06/13/锁的升级和对比/" itemprop="url">锁的升级和对比</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-06-13T15:49:22+08:00">
                2019-06-13
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="锁的状态"><a href="#锁的状态" class="headerlink" title="锁的状态"></a>锁的状态</h3><p>​    锁一共有4种状态，级别从低到高依次是：无锁状态、偏向锁状态、轻量级锁状态和重量级锁状态。锁可以升级但不能降级，目的是为了提高获得锁和释放锁的效率。</p>
<p><strong>1.偏向锁</strong></p>
<p>​    大多数情况下，锁不仅不存在多线程竞争，而且总是由同一线程获得，为了让线程获得锁的代价更低而引入了偏向锁。当一个线程访问同步块并获取锁时，会在对象头和栈帧中的锁记录里存储锁偏向的线程ID，以后该线程在进入和退出同步块时不需要进行CAS操作来加锁和解锁，只需测试对象头重是否存储着指向当前线程的偏向锁。测试失败则如果偏向锁标记为1，则尝试使用CAS将对象头的偏向锁指向当前线程。如果没有则使用CAS竞争锁。</p>
<p>​    若关闭偏向锁则程序默认进入轻量级锁状态。</p>
<p><strong>2.轻量级锁</strong></p>
<p><em>加锁</em></p>
<p>线程在执行同步块之前，JVM会先在当前线程的栈帧中创建用于存储锁记录的空间，并将对象头重的Mark Word复制到锁记录中(Displaced Mark Word)。然后线程尝试使用CAS将对象头中的Mark Word替换为指向锁记录的指针，如果成功线程获得锁，失败则表示其他线程竞争锁，当前线程便尝试使用自旋来获取锁。</p>
<p><em>解锁</em></p>
<p>解锁时会用原子的CAS操作将DIsplaced Mark Word替换回到对象头。如果成功表示没有竞争发生，如果失败，表示当前锁存在竞争，锁会膨胀成重量级锁。</p>
<p><strong>3.重量级锁</strong></p>
<p>自旋会消耗CPU，为了避免无用的自旋(比如获得锁的线程被阻塞住了)，一旦锁升级为重量级锁，就不会恢复到轻量级锁状态。在重量级锁状态下，其他线程试图获取锁时，都会被阻塞住，当持有锁的线程释放锁之后会唤醒这些线程，被唤醒的线程会再次争夺锁。</p>
<h3 id="原子操作-锁和CAS"><a href="#原子操作-锁和CAS" class="headerlink" title="原子操作(锁和CAS)"></a>原子操作(锁和CAS)</h3><p><strong><em>PS:CAS操作</em></strong></p>
<p>​    比较并交换：CAS操作需要输入两个数值，一个旧值(期望操作前的值)和一个新值，在操作期间先比较旧值有没有发生变化，如果没有发生变化，才叫换成新值，发生了变化则不交换，CAS使用版本号是因为为了解决ABA问题，一个值从A——&gt;B——&gt;A，检查，只能保证一个共享变量的原子操作，并发包中的AtomicReference类来保证引用对象之间的原子性，就可以把多个变量放在一个对象里来进行CAS操作。</p>
<p>i++不是一个原子操作，i++是一个经典的读改写操作，i++也不是线程安全的，i++的过程是</p>
<p><strong>1.从内存中把i的值取出来放到CPU的寄存器中</strong></p>
<p><strong>2.CPU寄存器的值+1</strong></p>
<p><strong>3.把CPU寄存器的值写回内存</strong></p>
<p>对于读值，+1，写值这三步操作，在这三步任何之间都可能会有CPU调度产生，造成i的值被修改，造成脏读脏写。</p>
<p>Java中通过锁和循环CAS的方式来实现原子操作。其中循环CAS就是使用并发包中的一些类(Atomic+)，如AtomicBoolean(用原子方式更新的boolean值)、AtomicInteger(用原子方式更新的int值)和AtomicLong(用原子方式更新的long值)，还提供了有用的工具方法，比如以原子的方式将当前值自增1和自减1。</p>
<p>JVM内部实现了偏向锁、轻量级锁和互斥锁，除了偏向锁，JVM实现锁的方式都用了循环CAS，即当一个线程想进入同步块的时候使用循环CAS的方式来获取锁，当退出同步块的时候使用循环CAS释放锁。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/06/03/常见SQL语句/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Saikikky Wang">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Saikikky">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/06/03/常见SQL语句/" itemprop="url">常见SQL语句</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-06-03T08:59:05+08:00">
                2019-06-03
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <ul>
<li><p>现有学生表student(s_id, name)和借书表book(b_id, s_id)</p>
<p>要查找没有借书记录的学生信息</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> s_id <span class="keyword">from</span> student <span class="keyword">where</span> s_id <span class="keyword">not</span> <span class="keyword">in</span> (<span class="keyword">select</span> s_id <span class="keyword">from</span> book);</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> s_id <span class="keyword">from</span> student <span class="keyword">left</span> <span class="keyword">join</span> book <span class="keyword">on</span> student.s_id=book.s_id <span class="keyword">where</span> book.s_id=<span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> book <span class="keyword">where</span> (<span class="keyword">select</span> <span class="keyword">count</span>(<span class="number">1</span>) <span class="keyword">as</span> <span class="keyword">num</span> <span class="keyword">from</span> student <span class="keyword">where</span> student.s_id=book.s_id) = <span class="number">0</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p>SQL Count(*)、group by、Having的联合使用</p>
<p>COUNT(*)  函数返回在给定的选择中被选的行数。</p>
<p>语法：SELECT  COUNT（*） FROM  table 返回总记录数</p>
<p>表app_category与表category关联。且表间关系是一对多，即同一个app_category_id 对应多个category-id,现在我需要统计出每一个category_id在app_category表中出现的次数那么该如何实现呢？</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> category_id, <span class="keyword">COUNT</span>(*) <span class="keyword">AS</span> <span class="keyword">count</span> <span class="keyword">from</span> app_category <span class="keyword">group</span> <span class="keyword">by</span> category_id;</span><br></pre></td></tr></table></figure>
<p>查询只有count的值大于2的时候 以id分组统计，查询分组后数量大于2的id和数量。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> category_id ,<span class="keyword">COUNT</span>(*) <span class="keyword">AS</span> <span class="keyword">count</span> <span class="keyword">FROM</span> app_category <span class="keyword">GROUP</span> <span class="keyword">BY</span> category_id <span class="keyword">HAVING</span> <span class="keyword">count</span>(category_id) &gt;<span class="number">2</span></span><br></pre></td></tr></table></figure>
<p>CARD 借书卡：          CNO 卡号，NAME 姓名，CLASS 班级</p>
<p>BOOKS 图书：           BNO 书号，BNAME 书名,AUTHOR 作者，PRICE 单价，QUANTITY 库存册数</p>
<p>BORROW 借书记录：  CNO 借书卡号，BNO 书号，RDATE 还书日期</p>
<p>找出借书超过5本的读者,输出借书卡号及所借图书册数</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> CNO,借图书册数=<span class="keyword">COUNT</span>(*)</span><br><span class="line"><span class="keyword">FROM</span> BORROW</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> CNO</span><br><span class="line"><span class="keyword">HAVING</span> <span class="keyword">COUNT</span>(*)&gt;<span class="number">5</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>like通配符</p>
<p>| 通配符 |                             说明                             |<br>| :—-: | :———————————————————-: |<br>|   _    |                      <strong>与任意字符匹配</strong>                      |<br>|   %    |                <strong>与包含一个或多个字符串匹配</strong>                |<br>|   []   | <strong>与特定范围</strong>(例如[a-d]或特定集例如[abcdef])中的任意字符串匹配<strong> |<br>|  [^]   | </strong>与特定范围（例如，[[^^a-f]]）或特定集（例如，[[^^abcdef]]）之外的任意单字符匹配。** |</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">查询id为100开头的学生信息</span><br><span class="line"><span class="keyword">Select</span> * fromStudent <span class="keyword">where</span> <span class="keyword">id</span> <span class="keyword">like</span> ‘<span class="number">100</span>%’;</span><br><span class="line"></span><br><span class="line">查询id为99结尾的学生信息</span><br><span class="line"><span class="keyword">Select</span> * <span class="keyword">from</span> Student <span class="keyword">where</span> <span class="keyword">id</span> <span class="keyword">like</span> ‘%<span class="number">99</span>’;</span><br><span class="line"></span><br><span class="line">查询id包含11在中间的学校信息</span><br><span class="line"><span class="keyword">Select</span>* <span class="keyword">from</span> Student <span class="keyword">where</span> <span class="keyword">id</span> <span class="keyword">like</span> %<span class="number">11</span>%;</span><br><span class="line"></span><br><span class="line">• WHERE name LIKE '_qiu' 可以找到所有三个字母的、以 qiu'结尾的名字（例如，xiaoqiu、daqiu）。 </span><br><span class="line">• WHERE name LIKE '% qiu'可以找到姓以qiu'结尾的所有员工。 </span><br><span class="line">• WHERE name LIKE '% qiu' %' 可以找到姓中任意位置包括qiu'的所有员工。 </span><br><span class="line">• WHERE name LIKE '[X] qiu'可以找到三个字母的、以qiu'结尾并以 X 开始的名字（即仅有 Xiaoqiu 和 Tim） </span><br><span class="line">• WHERE name LIKE x[^x]%' 可以找到以 x开始的、后面的（第二个）字母不为 x 的所有姓。</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p>max函数</p>
<p>查询现有图书中价格最高的图书，输出书名及作者</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> BNO,BNAME,AUTHOR <span class="keyword">FROM</span> BOOKS</span><br><span class="line"><span class="keyword">WHERE</span> PRICE=(</span><br><span class="line">    <span class="keyword">SELECT</span> <span class="keyword">MAX</span>(PRICE) <span class="keyword">FROM</span> BOOKS)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p>查询当前借了”计算方法”但没有借”计算方法习题集”的读者，输出其借书卡号，并按卡号降序排序输出</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> a.CNO</span><br><span class="line"><span class="keyword">FROM</span> BORROW a,BOOKS b</span><br><span class="line"><span class="keyword">WHERE</span> a.BNO=b.BNO <span class="keyword">AND</span> b.BNAME=N‘计算方法‘</span><br><span class="line">    <span class="keyword">AND</span> <span class="keyword">NOT</span> <span class="keyword">EXISTS</span>(</span><br><span class="line">        <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> BORROW aa,BOOKS bb</span><br><span class="line">        <span class="keyword">WHERE</span> aa.BNO=bb.BNO</span><br><span class="line">            <span class="keyword">AND</span> bb.BNAME=N‘计算方法习题集‘</span><br><span class="line">            <span class="keyword">AND</span> aa.CNO=a.CNO)</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> a.CNO <span class="keyword">DESC</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>将”C01”班同学所借图书的还期都延长一周</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> b <span class="keyword">SET</span> RDATE=<span class="keyword">DATEADD</span>(<span class="keyword">Day</span>,<span class="number">7</span>,b.RDATE)</span><br><span class="line"><span class="keyword">FROM</span> CARD a,BORROW b</span><br><span class="line"><span class="keyword">WHERE</span> a.CNO=b.CNO</span><br><span class="line">    <span class="keyword">AND</span> a.CLASS=N‘C01‘</span><br></pre></td></tr></table></figure>
</li>
<li><p>从BOOKS表中删除当前无人借阅的图书记录</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> A <span class="keyword">FROM</span> BOOKS a</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">NOT</span> <span class="keyword">EXISTS</span>(</span><br><span class="line">    <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> BORROW</span><br><span class="line">    <span class="keyword">WHERE</span> BNO=a.BNO)</span><br></pre></td></tr></table></figure>
</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/05/31/面试问题/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Saikikky Wang">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Saikikky">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/05/31/面试问题/" itemprop="url">面试问题</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-05-31T10:30:35+08:00">
                2019-05-31
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="1-关于static静态"><a href="#1-关于static静态" class="headerlink" title="1. 关于static静态"></a>1. 关于static静态</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestClass</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testMethod</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"testMethod"</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ((TestClass)<span class="keyword">null</span>).testMethod();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该代码可以正常执行输出”testMethod”，若去掉static就会空指针异常。</p>
<p>null可以转化成任何类型；</p>
<p>private只是权限声明，被其修饰的类、属性以及方法只能被该类的对象访问，其子类不能访问，更不能允许跨包访问；</p>
<p>static关键字，可以不用实例化，通过类名.方法名访问，也可以通过实例化类的对象，通过对象.方法名访问，但不能通过this关键字访问，static是类方法，在类加载的时候就已经存在，先于任何对象存在，this指代的是当前对象，但对象是在创建时才会在内存中生成的，所以不能使用static。</p>
<h2 id="2-值传递和引用传递"><a href="#2-值传递和引用传递" class="headerlink" title="2. 值传递和引用传递"></a>2. 值传递和引用传递</h2><p><strong>数据在内存中的存储</strong></p>
<ul>
<li><p>基本数据类型的局部变量</p>
<p><strong>直接存储在内存的栈上，也就是虚拟机栈，数据本身的值就存储在栈空间里</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> age = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> weight = <span class="number">10</span>;</span><br></pre></td></tr></table></figure>
<p>若栈中没有值为10的地址，开辟一块地址给10，并把age指向10，weight直接指向10，栈中的数据在当前线程下是共享的。</p>
<p><strong>基本数据类型的数据本身是不会改变的，当局部变量重新赋值时，并不是在内存中改变字面量内容，而是重新在栈中寻找已存在的相同的数据，若栈中不存在，则重新开辟内存存新数据，并且把要重新赋值的局部变量的引用指向新数据所在地址。</strong></p>
</li>
<li><p>基本数据类型的成员变量(类体中定义的变量)</p>
<p>虚拟机栈指向堆内存中的一块区域，故<strong>成员变量名和值都存储在堆中</strong>，生命周期和对象是一致的。</p>
</li>
<li><p>基于数据类型的静态变量</p>
<p>方法区中存储着一些共享数据，基本数据类型的静态变量名以及值存储于方法区的运行时常量池，静态变量随类加载而加载，随类消失而消失。</p>
</li>
<li><p>引用数据类型(类、接口、数组)</p>
<p><strong>对于引用数据类型的对象/数组，变量名存在栈中，变量值存储的是对象的地址，并不是对象的实际内容。</strong></p>
</li>
</ul>
<p><strong>值传递</strong></p>
<p>在方法被调用时，实参通过形参把它的内容副本传入方法内部，此时形参接收到的内容是实参值的一个拷贝，因此在方法内对形参的任何操作，都仅仅是对这个副本的操作，不影响原始值的内容。</p>
<p>主方法中的值存在于主方法的栈帧中，副本函数使用的是在函数的栈帧中。</p>
<p><strong>引用传递</strong></p>
<p>”引用”也就是指向真实内容的地址值，在方法调用时，实参的地址通过方法调用被传递给相应的形参，在方法体内，形参和实参指向通愉快内存地址，对形参的操作会影响的真实内容。引用传递在Java中并不存在。无论是基本类型和是引用类型，在实参传入形参时，都是值传递，也就是说传递的都是一个副本，而不是内容本身。但是传入引用对象时，是将指针指向同一块内存区域。</p>
<p><strong>如果是对基本数据类型的数据进行操作，由于原始内容和副本都是存储实际值，并且是在不同的栈区，因此形参的操作，不影响原始内容。</strong></p>
<p><strong>如果是对引用类型的数据进行操作，分两种情况，一种是形参和实参保持指向同一个对象地址，则形参的操作，会影响实参指向的对象的内容。一种是形参被改动指向新的对象地址（如重新赋值引用），则形参的操作，不会影响实参指向的对象的内容。</strong></p>
<h2 id="3-equals和hashcode"><a href="#3-equals和hashcode" class="headerlink" title="3. equals和hashcode"></a>3. equals和hashcode</h2><p><strong>==和equals</strong></p>
<p>equals覆盖之前等于==，用于判断两个对象是否是同一个对象，即他们的地址是否相等。覆盖equals是为了逻辑上的相等，即值相等或者内容相等。(违反对称性和传递性的情况??)</p>
<p>String类中的equals方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object anObject)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">       <span class="comment">//如果是同一个对象</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == anObject)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果传递进来的参数是String类的实例</span></span><br><span class="line">        <span class="keyword">if</span> (anObject <span class="keyword">instanceof</span> String)</span><br><span class="line">        &#123;</span><br><span class="line">            String anotherString = (String)anObject;</span><br><span class="line">            <span class="keyword">int</span> n = count;<span class="comment">//字符串长度</span></span><br><span class="line">            <span class="keyword">if</span> (n == anotherString.count) <span class="comment">//如果长度相等就进行比较</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">char</span> v1[] = value;<span class="comment">//取每一个位置的字符</span></span><br><span class="line">                <span class="keyword">char</span> v2[] = anotherString.value;</span><br><span class="line">                <span class="keyword">int</span> i = offset;</span><br><span class="line">                <span class="keyword">int</span> j = anotherString.offset;</span><br><span class="line">                <span class="keyword">while</span> (n-- != <span class="number">0</span>) <span class="comment">//对于每一位置逐一比较</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span> (v1[i++] != v2[j++])</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>覆盖equals时一定要覆盖hashCode方法</p>
<p>Object.hashCode方法中规定：<strong>如果两个对象根据equals(Object)方法比较是相等的，则调用这两个对象中任意一个对象的hashCode方法必须产生同样的整数结果。</strong>即equals相等，hashCode必须相等。</p>
<p>比如hashMap，正常情况下两个值相等的值，在hashMap中要插入第二个时应该覆盖第一个，即相同的值指插入一个，若覆盖了equals没有覆盖hashCode，则会将两个都插入。</p>
<p>如果覆盖equals没有覆盖hashCode，将会违反：相等的对象必须具有相等的散列码(hashCode)。Object类里面的默认equals方法是比较内存地址是否相等，默认的hashCode方法则是根据内存地址产生一个整数，所以Object类本身当然是符合上面规则的。当你覆盖了equals后，内存地址不同的对象可能会相等，而如果这时你没有覆盖hashCode方法的话，hashCode还是根据内存地址来生成，就会出现相等的对象具有不同的散列码的情况。</p>
<p>反过来覆盖hashCode并不一定要覆盖equals方法。</p>
</li>
</ul>
<h2 id="4-Hashtable和HashMap"><a href="#4-Hashtable和HashMap" class="headerlink" title="4.Hashtable和HashMap"></a>4.Hashtable和HashMap</h2><ul>
<li><p>继承和实现方法不同</p>
<ul>
<li>HashMap和Hashtable都实现了Map、Cloneable、java.io.Serializable接口</li>
<li>HashMap继承于AbstractMap，而Hashtable继承于Dictionary</li>
</ul>
</li>
<li><p>Hashtable是线程安全的，HashMap不是</p>
<p>要使HashMap线程安全，可以使用Collections的synchronizedMap静态方法，或者直接使用JDK 5.0之后提供的java.util.concurrent包里的ConcurrentHashMap类。故Hashtable效率比较低。</p>
<p>为什么Hashtable是线程安全的，它的remove,put，get做成了同步方法，保证了Hashtable的线程安全性。</p>
</li>
<li><p>HashMap的key、value都可以为null，Hashtable的key、value都不可以为null。</p>
<p> 当HashMap的key为null时，HashMap会将其固定的插入table[0]位置(即HashMap散列表的第一个位置)；而且table[0]处只会容纳一个key为null的值，当有多个key为null的值插入的时候，table[0]会保留最后插入的value。</p>
<p>put()方法实现：首先hash(key)得到key的hashcode()，hashmap根据获得的hashcode找到要插入的位置所在的链，在这个链里面放的都是hashcode相同的Entry键值对，在找到这个链之后，会通过equals()方法判断是否已经存在要插入的键值对，而这个equals比较的其实就是key。它用来存放key-value这样的一个键值对，返回值是key在Map中存放的旧value，如果之前不存在则返回null。HashMap的put方法是这样实现的。</p>
</li>
<li><p>容量的初始值和扩容方式不同</p>
<ul>
<li><p>HashMap默认的容量大小是16；增加容量时，每次将容量变为“原始容量x2”。为2^n</p>
<p>确定数组位置的实现是 <code>i=（n-1）&amp; hash</code>，当n为2的幂次方时，（n-1）&amp; hash 的值是均匀分布的。而且当n是2的幂次方时：hash &amp; (length - 1) == hash % length，&amp;性能比%好。</p>
</li>
<li><p>Hashtable默认的容量大小是11；增加容量时，每次将容量变为“原始容量x2 + 1”。</p>
</li>
</ul>
</li>
<li><p>添加key-value时的hash值算法不同</p>
<ul>
<li>HashMap添加元素时，是使用自定义的哈希算法。</li>
<li>Hashtable没有自定义哈希算法，而直接采用的key的hashCode()。</li>
</ul>
</li>
<li><p>遍历方法不同</p>
<ul>
<li>HashMap只支持Iterator(迭代器)遍历。</li>
<li>而Hashtable支持Iterator(迭代器)和Enumeration(枚举器)两种方式遍历。</li>
</ul>
<p>Hashtable古老，父类被弃用，<code>但同步机制并不能避免在iterator或Enumeration遍历过程中其他线程对Hashtable的put、 remove、clear操作，这些写操作都会被毫无阻拦得成功执行。</code>  (不确定？？) 主要应该是同步导致的性能开销问题弃用。</p>
</li>
</ul>
<h3 id="HashMap的死循环问题-在并发条件下"><a href="#HashMap的死循环问题-在并发条件下" class="headerlink" title="HashMap的死循环问题(在并发条件下)"></a>HashMap的死循环问题(在并发条件下)</h3><p>扩容时链表成环，导致执行get操作的时候造成死循环。问题出在transfer函数，即扩容之后的数据迁移部分。transfer函数：首先获取新表的长度，之后遍历新表的每一个entry，然后每个ertry中的链表，以反转的形式，形成rehash之后的链表。</p>
<p>并发问题：</p>
<p><strong>若当前线程此时获得entry节点，但是被线程中断无法继续执行，此时线程二进入transfer函数，并把函数顺利执行，此时新表中的某个位置有了节点，之后线程一获得执行权继续执行，因为并发transfer，所以两者都是扩容的同一个链表，当线程一执行到e.next = new table[i] 的时候，由于线程二之前数据迁移的原因导致此时new table[i] 上就有ertry存在，所以线程一执行的时候，会将next节点，设置为自己，导致自己互相使用next引用对方，因此产生链表，导致死循环。</strong>(这个过程还需要再看看图和代码执行顺序)</p>
<h3 id="concurrentHashMap"><a href="#concurrentHashMap" class="headerlink" title="concurrentHashMap"></a>concurrentHashMap</h3><p><strong>concurrentHashMap不支持key和value 值为null的原因</strong>：ConcurrentHashmap和Hashtable都是支持并发的，这样会有一个问题，当你通过get(k)获取对应的value时，如果获取到的是null时，你无法判断，它是put（k,v）的时候value为null，还是这个key从来没有做过映射。HashMap是非并发的，可以通过contains(key)来做这个判断。而支持并发的Map在调用m.contains（key）和m.get(key),m可能已经不同了。</p>
<h2 id="5-synchronized关键字"><a href="#5-synchronized关键字" class="headerlink" title="5.synchronized关键字"></a>5.synchronized关键字</h2><ul>
<li><p>修饰方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="comment">// todo</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>跟下面的修饰代码块的代码是等价的。</p>
<p>Synchronized关键字不能被继承，如果在父类中的某个方法使用了synchronized关键字，而在子类中覆盖了这个方法，在子类中的这个方法默认情况下并不是同步的，而必须显式地在子类的这个方法中加上synchronized关键字才可以。当然，还可以在子类方法中调用父类中相应的方法，这样虽然子类中的方法不是同步的，但子类调用了父类的同步方法，因此，子类的方法也就相当于同步了。</p>
<ul>
<li>在定义接口方法时不能使用synchronized关键字。</li>
<li>构造方法不能使用synchronized关键字，但可以使用synchronized代码块来进行同步。 </li>
</ul>
</li>
<li><p>修饰代码块</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">synchronized</span>(<span class="keyword">this</span>) &#123;</span><br><span class="line">      <span class="comment">// todo</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>一个线程访问一个对象中的synchronized(this)同步代码块时，其他试图访问该对象的线程将被阻塞</li>
<li>当一个线程访问对象的一个synchronized(this)同步代码块时，另一个线程仍然可以访问该对象中的非synchronized(this)同步代码块</li>
</ul>
</li>
<li><p>指定给某个对象加锁</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method3</span><span class="params">(SomeObject obj)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="comment">//obj 锁定的对象</span></span><br><span class="line">   <span class="keyword">synchronized</span>(obj)</span><br><span class="line">   &#123;</span><br><span class="line">      <span class="comment">// todo</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>修饰一个静态方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="comment">// todo</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>静态方法是属于类的而不属于对象的。同样的，synchronized修饰的静态方法锁定的是这个类的所有对象。</p>
</li>
<li><p>修饰类 与修饰静态方法类似，给整个类加锁</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClassName</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">synchronized</span>(ClassName.class) &#123;</span><br><span class="line">         <span class="comment">// todo</span></span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><strong>无论synchronized关键字加在方法上还是对象上，如果它作用的对象是非静态的，则它取得的锁是对象；如果synchronized作用的对象是一个静态方法或一个类，则它取得的锁是对类，该类所有的对象同一把锁。 </strong></p>
<p><strong>synchronized methods(){} 与synchronized（this）{}之间没有什么区别，只是synchronized methods(){} 便于阅读理解，而synchronized（this）{}可以更精确的控制冲突限制访问区域，有时候表现更高效率。</strong></p>
<h2 id="6-索引"><a href="#6-索引" class="headerlink" title="6.索引"></a>6.索引</h2><ul>
<li><p>优点</p>
<ul>
<li>创建唯一性索引，保证数据库表中每一行数据的唯一性</li>
<li>大大加快数据的检索速度，这也是创建索引的最主要的原因</li>
<li>加速表和表之间的连接，特别是在实现数据的参考完整性方面特别有意义。</li>
<li>在使用分组和排序子句进行数据检索时，同样可以显著减少查询中分组和排序的时间。</li>
<li>通过使用索引，可以在查询的过程中使用优化隐藏器，提高系统的性能。</li>
</ul>
</li>
<li><p>缺点</p>
<ul>
<li>创建索引和维护索引要耗费时间，这种时间随着数据量的增加而增加</li>
<li>索引需要占物理空间，除了数据表占数据空间之外，每一个索引还要占一定的物理空间，如果要建立聚簇索引，那么需要的空间就会更大</li>
<li>当对表中的数据进行增加、删除和修改的时候，索引也要动态的维护，降低了数据的维护速度</li>
</ul>
</li>
<li><p>索引的最左前缀匹配原则</p>
<p>在mysql建立联合索引时会遵循最左前缀匹配的原则，即最左优先，在检索数据时从联合索引的最左边开始匹配，示例：<br>对列col1、列col2和列col3建一个联合索引</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">KEY test_col1_col2_col3 on test(col1,col2,col3);</span><br></pre></td></tr></table></figure>
<p>联合索引 test_col1_col2_col3 实际建立了(col1)、(col1,col2)、(col,col2,col3)三个索引。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM test WHERE col1=“1” AND clo2=“2” AND clo4=“4”</span><br></pre></td></tr></table></figure>
<p>上面这个查询语句执行时会依照最左前缀匹配原则，检索时会使用索引(col1,col2)进行数据匹配。</p>
<ul>
<li>注意</li>
</ul>
<p>索引的字段是可以任意顺序的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM test WHERE col1=“1” AND clo2=“2”</span><br><span class="line">SELECT * FROM test WHERE col2=“2” AND clo1=“1”</span><br></pre></td></tr></table></figure>
<p>这两个查询语句都会用到索引(col1,col2)，mysql创建联合索引的规则是首先会对联合合索引的最左边的，也就是第一个字段col1的数据进行排序，在第一个字段的排序基础上，然后再对后面第二个字段col2进行排序。其实就相当于实现了类似 order by col1 col2这样一种排序规则。</p>
<p>第二个语句可以借助mysql查询优化器explain，explain会纠正sql语句该以什么样的顺序执行效率最高，最后才生成真正的执行计划。既然结果一样，那什么执行顺序是最好的。</p>
<p><strong>因为辅助索引是B+树实现的，虽然可以指定多个列，但是每个列的比较优先级不一样，写在前面的优先比较。一旦出现遗漏，在B+树上就无法继续搜索了（通过补齐等措施解决的除外），因此是按照最左连续匹配来的。既然是在B+树上搜索，对于条件的比较自然是要求精确匹配（即”=”和”IN”）。不过顺序倒是可以颠倒，因为查询优化器重排序一下就好了。</strong></p>
</li>
</ul>
<p>  <strong><em>当b+树的数据项是复合的数据结构，比如(name,age,sex)的时候，b+数是按照从左到右的顺序来建立搜索树的，比如当(张三,20,F)这样的数据来检索的时候，b+树会优先比较name来确定下一步的所搜方向，如果name相同再依次比较age和sex，最后得到检索的数据；但当(20,F)这样的没有name的数据来的时候，b+树就不知道下一步该查哪个节点，因为建立搜索树的时候name就是第一个比较因子，必须要先根据name来搜索才能知道下一步去哪里查询。比如当(张三,F)这样的数据来检索时，b+树可以用name来指定搜索方向，但下一个字段age的缺失，所以只能把名字等于张三的数据都找到，然后再匹配性别是F的数据了， 这个是非常重要的性质，即索引的最左匹配特性。</em></strong></p>
<h2 id="7-Autowired"><a href="#7-Autowired" class="headerlink" title="7.@Autowired"></a>7.@Autowired</h2><p>自动装配原理：在容器启动，为对象赋值的时候，会用后置处理器机制，来创建属性的实例，然后再利用反射机制，将实例化好的属性赋值给对象上。</p>
<p>同一类型注入多次为同一实例(单例模式)</p>
<ul>
<li><p>@Autowired默认<strong>按类型装配</strong>（这个注解是属于<strong>Spring</strong>的），默认情况下必须要求依赖对象必须存在，如果要允许null值，可以设置它的required属性为false，如：@Autowired(required=false) </p>
<p>如果我们想使用名称装配可以结合@Qualifier注解进行使用</p>
<p>@Qualifier注解当bean不唯一时使用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span>() <span class="meta">@Qualifier</span>(<span class="string">"baseDao"</span>)    </span><br><span class="line"><span class="keyword">private</span> BaseDao baseDao;</span><br></pre></td></tr></table></figure>
</li>
<li><p>@Resource <strong>是JDK1.6支持的注解</strong>，<strong>默认按照名称进行装配</strong>，名称可以通过name属性进行指定，如果没有指定name属性，当注解写在字段上时，默认取字段名，按照名称查找，如果注解写在setter方法上默认取属性名进行装配。当找不到与名称匹配的bean时才按照类型进行装配。但是需要注意的是，如果name属性一旦指定，就只会按照名称进行装配。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Resource</span>(name=<span class="string">"baseDao"</span>)    </span><br><span class="line"><span class="keyword">private</span> BaseDao baseDao;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><strong>byName</strong> 通过参数名 自动装配，如果一个bean的name 和另外一个bean的 property 相同，就自动装配。<br><strong>byType</strong> 通过参数的数据类型自动自动装配，如果一个bean的数据类型和另外一个bean的property属性的数据类型兼容，就自动装配。</p>
<p>@Required注解检查 但他只检查属性是否已经设置而不会测试属性是否非空</p>
<h2 id="8-如何定位并优化慢查询Sql"><a href="#8-如何定位并优化慢查询Sql" class="headerlink" title="8. 如何定位并优化慢查询Sql"></a>8. 如何定位并优化慢查询Sql</h2><ul>
<li><p>根据慢日志定位慢查询sql</p>
</li>
<li><p>使用explain等工具分析sql</p>
<p>type:index/all 可能需要优化</p>
<p>extra: using filesort/using temporary(临时表常用于order by和group by)可能需要优化 表示根本不能使用索引，效率会受到极大影响。</p>
</li>
<li><p>修改sql或者尽量让sql走索引</p>
</li>
</ul>
<h2 id="9-最左匹配原则"><a href="#9-最左匹配原则" class="headerlink" title="9. 最左匹配原则"></a>9. 最左匹配原则</h2><p>​        建立(a,b,c)索引可以任意顺序，mysql的查询优化器会帮助你优化成索引可以识别的形式，但必须遵循最左匹配原则。最左匹配原则的成因是第二个的查找是在第一个的基础上进行的。如果没有第一个的查找锁定就找不到合适的数据。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/05/29/hello-world/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Saikikky Wang">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Saikikky">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/05/29/hello-world/" itemprop="url">Hello World</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-05-29T19:44:40+08:00">
                2019-05-29
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">Saikikky Wang</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">20</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                
                  <span class="site-state-item-count">5</span>
                  <span class="site-state-item-name">tags</span>
                
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Saikikky Wang</span>

  
</div>



  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>




  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Mist</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
